<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="google-site-verification" content="-zz_UiN3Z6szo1tjCMg8H66_XeAH2-dL2KLimiLJ0Ak"><meta name="author" content="Rose Ou"><meta name="description" conauthortent="Fighting!"><link rel="alternative" href="/atom.xml" title="RoseOu's blog" type="application/atom+xml"><link rel="icon" href="/favicon.png"><title>查找算法 - RoseOu's blog</title><link rel="stylesheet" href="/css/main.css"><!--[if lt IE 9]><script>(function(a,b){a="abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video".split(" ");for(b=a.length-1;b>=0;b--)document.createElement(a[b])})()</script><![endif]--><script src="/js/jquery-3.1.1.min.js"></script><!-- Hotjar Tracking Code for ochukai.me --></head><body style="opacity:0"><header class="head"><h1 class="head-title u-fl"><a href="/">RoseOu's blog</a></h1><nav class="head-nav u-fr"><ul class="head-nav__list"><li class="head-nav__item"><a href="/archives" class="head-nav__link">目录</a></li></ul></nav></header><main class="main"><article class="post"><header class="post__head">  <time datetime="2017-04-28T06:01:58.000Z" class="post__time">四月 28, 2017</time><h1 class="post__title"><a href="/2017/04/28/查找算法/">查找算法</a></h1><div class="post__main echo"><h2 id="一、查找算法的相关概念"><a href="#一、查找算法的相关概念" class="headerlink" title="一、查找算法的相关概念"></a>一、查找算法的相关概念</h2><p><strong>关键字的定义：</strong> 关键字是数据元素中某个数据项的值，用它可以标识一个数据元素。<br><strong>查找的定义：</strong> 用关键字标识数据元素，查找时根据给定的值，在表中确定一个关键字的值等于给定值的记录或数据元素。<br><strong>查找算法的分类：</strong><br>(1).无序查找和有序查找：无序查找即被查找数列有序无序均可.有序查找即被查找数列必须为有序数列。<br>(2).静态查找和动态查找：静态或者动态都是针对查找表而言的。动态表指查找表中有删除和插入操作的表。<br><strong>平均查找长度（ASL）：</strong> 查找过程中先后和给定值进行比较的数据元素的关键字个数的期望值，称为查找算法在查找成功时的平均查找长度。对于含有n个数据元素的查找表，查找成功的平均查找长度为：<strong>ASL=∑Pi*Ci (i=1,2,3,…,n)</strong>。<br>Pi：查找表中第i个数据元素的概率,且∑Pi=1（i=1,2,3,…,n）<br>Ci：找到第i个数据元素（其关键字等于给定值）时和给定值进行过比较的关键字的个数，显然，Ci的值随查找过程的不同而不同。</p>
<h2 id="二、六种查找算法"><a href="#二、六种查找算法" class="headerlink" title="二、六种查找算法"></a>二、六种查找算法</h2><p>以下所有算法讨论涉及的数据元素统一定义为如下描述的类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> KeyType;  <span class="comment">//关键字类型以int为例</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</div><div class="line">    KeyType key;</div><div class="line">&#125; ElemType;</div></pre></td></tr></table></figure>
<p><strong>注意：</strong> 每个算法只给出核心代码，完整代码请到我的<a href="https://github.com/RoseOu/Daily_Exercise/tree/master/algorithms/search_al" target="_blank" rel="external">Github</a>。</p>
<h3 id="1-顺序查找"><a href="#1-顺序查找" class="headerlink" title="1.顺序查找"></a>1.顺序查找</h3><p><strong>介绍：</strong> 顺序查找也称为线形查找，属于无序查找算法。<br><strong>算法思想：</strong> 从线形表的第一个元素的关键字起，依次和给定值进行比较，若某个关键字与给定值相等，则查找成功；反之，若直到扫描结束其关键字和给定值比较都不相等，则表明表中没有所查的记录，查找失败。<br><img src="/images/search_al/sqsearch.gif"><br><strong>C++描述：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</div><div class="line">    ElemType *elem;</div><div class="line">    <span class="keyword">int</span> length;  <span class="comment">//表中数据元素个数</span></div><div class="line">&#125; SSTable;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">SqSearch</span><span class="params">(SSTable ST, KeyType kval)</span></span>&#123; <span class="comment">//kval为需要查找的给定值</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;ST.length+<span class="number">1</span>;i++)&#123;  <span class="comment">//依次和给定值进行比较</span></div><div class="line">        <span class="keyword">if</span> (ST.elem[i].key==kval)&#123;  <span class="comment">//若某个元素的关键字与给定值相等，则查找成功</span></div><div class="line">            <span class="keyword">return</span> i;    <span class="comment">//返回数据元素所在的顺序</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">//直到扫描结束仍然没有数据元素的关键字与给定值相等，查找失败，返回0</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于在循环条件中必须加上不使循环变量出界的判别，那么当数据元素个数超过1000时，因判出界操作的时间消耗很可观，它将使整个算法的执行时间几乎增加一倍，为此，可类似于插入排序的算法，在数组的“0下标”处增设“哨兵”，并令查找过程自最后一个元素的关键字开始。<br><strong>C++描述：</strong></p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">int SqSearch(SSTable ST, KeyType kval)&#123;</div><div class="line">    int i;</div><div class="line">    ST.<span class="built_in">elem</span>[<span class="number">0</span>].<span class="built_in">key</span>=kval;</div><div class="line">    <span class="keyword">for</span>(i=ST.<span class="built_in">length</span>;ST.<span class="built_in">elem</span>[i].<span class="built_in">key</span>!=kval;--i);</div><div class="line">    <span class="built_in">return</span> i;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>平均查找长度：</strong> 当查找成功时，<strong>ASL = 1/n(1+2+3+…+n) = (n+1)/2</strong>。<br><strong>时间复杂度分析：</strong> 当查找不成功时，需要n+1次比较，所以时间复杂度为<strong>O(n)</strong>。</p>
<h3 id="2-折半查找"><a href="#2-折半查找" class="headerlink" title="2.折半查找"></a>2.折半查找</h3><p><strong>介绍：</strong> 也称二分查找，属于有序查找算法。数据元素必须是有序的，如果是无序的则要先进行排序操作。<br><strong>算法思想：</strong> 用给定值先与中间数据元素的关键字比较，中间的数据元素把线形表分成两个子表，若相等则查找成功；若不相等，再根据给定值与该中间数据元素关键字的比较结果确定下一步查找哪个子表，这样逐步缩小范围，直至找到该记录，或者当查找区间缩小到0也没有找到等于给定值的关键字为止。<br><img src="/images/search_al/bisearch.gif"><br><strong>C++描述：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</div><div class="line">    ElemType *elem;</div><div class="line">    <span class="keyword">int</span> length;  <span class="comment">//表中数据元素个数</span></div><div class="line">&#125; SSTable;</div><div class="line"></div><div class="line"><span class="comment">//非递归实现</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinarySearch</span><span class="params">(SSTable ST, KeyType kval)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> low, high, mid;</div><div class="line">    low = <span class="number">1</span>;</div><div class="line">    high = ST.length;</div><div class="line">    <span class="keyword">while</span>(low&lt;=high)</div><div class="line">    &#123;</div><div class="line">        mid = (low+high)/<span class="number">2</span>;</div><div class="line">        <span class="keyword">if</span>(ST.elem[mid].key &gt; kval)&#123;</div><div class="line">            high = mid<span class="number">-1</span>;</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ST.elem[mid].key &lt; kval)&#123;</div><div class="line">            low = mid+<span class="number">1</span>;</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">        	<span class="keyword">return</span> mid;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//递归实现</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinarySearch</span><span class="params">(SSTable ST, KeyType kval, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> mid = low+(high-low)/<span class="number">2</span>;</div><div class="line">    <span class="keyword">if</span>(ST.elem[mid].key &gt; kval)&#123;</div><div class="line">        <span class="keyword">return</span> BinarySearch(ST, kval, low, mid<span class="number">-1</span>);</div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ST.elem[mid].key &lt; kval)&#123;</div><div class="line">        <span class="keyword">return</span> BinarySearch(ST, kval, mid+<span class="number">1</span>, high);</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">return</span> mid;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>平均查找长度：</strong> <strong>ASL = ((n+1)/n * log(n+1))-1</strong>。<br>对于任意表长n大于50的有序表，其折半查找的平均查找长度近似为：<br>ASL ≈ log(n+1)-1。<br><strong>时间复杂度分析：</strong> 最坏情况下，关键词比较次数为<strong>log(n+1)</strong>，且期望时间复杂度为<strong>O(logn)</strong>。<br><strong>注意：</strong> 可见折半查找的效率好于顺序查找，特别在表长较大时，其差别更大。但折半查找的前提条件是需要有序表顺序存储，对于静态查找表，一次排序后不再变化，折半查找能得到不错的效率。但对于需要频繁执行插入或删除操作的数据集来说，维护有序的排序会带来不小的工作量，那就不建议使用。</p>
<h3 id="3-分块查找"><a href="#3-分块查找" class="headerlink" title="3.分块查找"></a>3.分块查找</h3><p><strong>介绍：</strong> 分块查找又称索引顺序查找，实际上它是顺序查找的一种改进方法。其性能介于顺序查找和折半查找之间，它适合对“分块有序”的数据元素进行查找操作。<br><strong>算法思想：</strong> 将n个数据元素按”分块有序”划分为m块（m ≤ n），所谓“分块有序”是指数据元素可按其关键字的大小分成若干“块”，且“前一块”中的最大关键字小于“后一块”中的最小关键字，而各块内部的数据元素不一定有序。然后先从各块中抽取最大数据元素构成一个索引表，由于数据元素分块有序，所以索引表是有序的。接下来查找过程分两步进行：先在索引表中进行折半或顺序查找，以确定待查记录的“所在块”，然后在已限定的那一块中进行顺序查找。<br><img src="/images/search_al/blocksearch.png"><br>要注意的是，一般把下标为0的空间空出来。<br><strong>C++描述：</strong></p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">typedef struct&#123;</div><div class="line">    ElemType *<span class="built_in">elem</span>;</div><div class="line">    int <span class="built_in">length</span>;  //表中数据元素个数</div><div class="line">&#125; SSTable;</div><div class="line"></div><div class="line">typedef struct&#123;</div><div class="line">    KeyType <span class="built_in">key</span>;</div><div class="line">    int stadr;</div><div class="line">&#125; indexItem;</div><div class="line"></div><div class="line">typedef struct&#123;</div><div class="line">    indexItem *<span class="built_in">elem</span>;</div><div class="line">    int <span class="built_in">length</span>;</div><div class="line">&#125; indexTable;</div><div class="line"></div><div class="line">int Search_Idx(SSTable ST, indexTable ID, KeyType kval)&#123;</div><div class="line">    int low,high,mid,s,t,k;</div><div class="line">    bool found;</div><div class="line"></div><div class="line">    //在顺序表ST中分块查找等于给定值kval的数据元素，ID为索引表</div><div class="line">    //若找到，则返回该数据元素在ST中的位置，否则返回<span class="number">0</span></div><div class="line">    low=<span class="number">0</span>;</div><div class="line">    high=ID.<span class="built_in">length</span>-<span class="number">1</span>;</div><div class="line">    found=<span class="literal">false</span>;</div><div class="line">    <span class="keyword">if</span>(kval&gt;ID.<span class="built_in">elem</span>[high].<span class="built_in">key</span>)&#123; //当给定值kval比表中所有数据元素都大</div><div class="line">        <span class="built_in">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span>(low&lt;=high &amp;&amp; !found)&#123; //折半查找索引表，确定查找区间</div><div class="line">        mid=(low+high)/<span class="number">2</span>;</div><div class="line">        <span class="keyword">if</span>(kval&lt;ID.<span class="built_in">elem</span>[mid].<span class="built_in">key</span>)&#123;</div><div class="line">            high=mid-<span class="number">1</span>;</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(kval&gt;ID.<span class="built_in">elem</span>[mid].<span class="built_in">key</span>)&#123;</div><div class="line">            low=mid+<span class="number">1</span>;</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            found=<span class="literal">true</span>;low=mid;</div><div class="line">        &#125;</div><div class="line">    &#125;//<span class="keyword">while</span></div><div class="line">    s=ID.<span class="built_in">elem</span>[low].stadr;  //经索引表查找后，下一步的查找范围定位在第low块</div><div class="line">    <span class="keyword">if</span>(low&lt;ID.<span class="built_in">length</span>-<span class="number">1</span>)&#123;</div><div class="line">        t=ID.<span class="built_in">elem</span>[low+<span class="number">1</span>].stadr-<span class="number">1</span>;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        t=ST.<span class="built_in">length</span>;     //s和t为在ST表进行查找的下界和上界</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(ST.<span class="built_in">elem</span>[t].<span class="built_in">key</span>==kval)&#123;</div><div class="line">        <span class="built_in">return</span> t;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;          //在ST.<span class="built_in">elem</span>[s]至ST.<span class="built_in">elem</span>[t-<span class="number">1</span>]的区间内进行顺序查找</div><div class="line">        ST.<span class="built_in">elem</span>[<span class="number">0</span>]=ST.<span class="built_in">elem</span>[t];   //ST.<span class="built_in">elem</span>[<span class="number">0</span>]用来暂存ST.<span class="built_in">elem</span>[t]</div><div class="line">        ST.<span class="built_in">elem</span>[t].<span class="built_in">key</span>=kval;        //设置哨兵</div><div class="line">        <span class="keyword">for</span>(k=s;ST.<span class="built_in">elem</span>[k].<span class="built_in">key</span>!=kval;k++);</div><div class="line">        ST.<span class="built_in">elem</span>[t]=ST.<span class="built_in">elem</span>[<span class="number">0</span>];   //回复暂存值</div><div class="line">        <span class="keyword">if</span>(k!=t)&#123;</div><div class="line">            <span class="built_in">return</span> k;</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            <span class="built_in">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>平均查找长度：</strong> 由于分块查找实际上是进行了两次查找，则整个算法的平均查找长度是两次查找的平均查找长度之和。假设索引表的长度为b，顺序表的长度为n，则以二分查找确定块时整个分块查找的平均查找长度为：<br><strong>ASL(n)=ASL(b)+ASL(n/b)≈log(b+1)-1+(n/b+1)/2</strong>。<br><strong>注意：</strong> 一般情况下为进行索引顺序查找，不一定要将顺序表等分成若干块并提取每块的最大关键字作为索引项，有时也可根据顺序表中的关键字的特征来分块。</p>
<h3 id="4-插值查找"><a href="#4-插值查找" class="headerlink" title="4.插值查找"></a>4.插值查找</h3><p><strong>介绍：</strong> 在介绍插值查找之前，我们想想，为什么二分查找算法一定要是折半，而不是折四分之一或者折更多呢？打个比方，要在取值范围1 ~ 10000 之间 100 个元素从小到大均匀分布的数组中查找5，我们自然会考虑从数组下标较小的开始查找。也就是说，折半查找这种查找方式，不是自适应的。二分查找中查找点计算如下：<br><strong>mid=(low+high)/2, 即mid=low+1/2*(high-low)</strong><br><img src="/images/search_al/inbisearch.png"><br>通过类比，我们可以将查找的点改进为如下：<br><strong>mid=low+(key-a[low])/(a[high]-a[low])*(high-low)</strong><br><img src="/images/search_al/ininsearch.png"><br>也就是将上述的比例参数1/2改进为自适应的，根据关键字在整个有序表中所处的位置，让mid值的变化更靠近关键字key，这样也就间接地减少了比较次数。<br><strong>算法思想：</strong> 基于二分查找算法，将查找点的选择改进为自适应选择，可以提高查找效率。当然，插值查找也属于有序查找。<br><strong>C++描述：</strong></p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">typedef struct&#123;</div><div class="line">    ElemType *<span class="built_in">elem</span>;</div><div class="line">    int <span class="built_in">length</span>;  //表中数据元素个数</div><div class="line">&#125; SSTable;</div><div class="line"></div><div class="line">int InsertionSearch(SSTable ST, KeyType kval, int low, int high)</div><div class="line">&#123;</div><div class="line">    int mid = low+((kval-ST.<span class="built_in">elem</span>[low].<span class="built_in">key</span>)*(ST.<span class="built_in">elem</span>[high].<span class="built_in">key</span>-ST.<span class="built_in">elem</span>[low].<span class="built_in">key</span>)/(ST.<span class="built_in">elem</span>[high].<span class="built_in">key</span>-ST.<span class="built_in">elem</span>[low].<span class="built_in">key</span>));</div><div class="line">    <span class="keyword">if</span>(ST.<span class="built_in">elem</span>[mid].<span class="built_in">key</span> &gt; kval)&#123;</div><div class="line">        <span class="built_in">return</span> InsertionSearch(ST, kval, low, mid-<span class="number">1</span>);</div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ST.<span class="built_in">elem</span>[mid].<span class="built_in">key</span> &lt; kval)&#123;</div><div class="line">        <span class="built_in">return</span> InsertionSearch(ST, kval, mid+<span class="number">1</span>, high);</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="built_in">return</span> mid;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>时间复杂度分析：</strong> 查找成功或者失败的时间复杂度均为<strong>O(log(logn))</strong>。<br><strong>注意：</strong> 对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好的多。反之，数组中如果分布非常不均匀，那么插值查找未必是很合适的选择。</p>
<h3 id="5-二叉树查找"><a href="#5-二叉树查找" class="headerlink" title="5.二叉树查找"></a>5.二叉树查找</h3><p><strong>二叉查找树介绍：</strong> 二叉查找树也叫二叉排序树，它或者是一棵空树，或者是具有下列性质的二叉树：<br>（1）若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；<br>（2）若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；<br>（3）任意节点的左、右子树也分别为二叉查找树。<br><strong>算法思想：</strong> 对待查找的数据元素生成二叉查找树，然后将给定值和根结点的关键字进行比较，若相等，则查找成功，否则依据给定值小于或大于根结点的关键字，继续在左子树和右子树中进行查找，直至查找成功或者因左子树或右子树为空树为止，后者说明查找不成功。这个算法的查找效率很高，但是如果使用这种查找方法要首先创建二叉查找树。<br><img src="/images/search_al/bisearchtree.gif"><br><strong>注意：</strong> 这里要注意与折半查找的二叉判定树区分，二叉判定树是用来分析某个算法而设计的二叉树，而二叉排序树是用来对一组关键字进行排序的方法。<br><strong>C++描述：</strong></p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//创建二叉查找树</span></div><div class="line">void Insert_BST(BiTree &amp;T,KeyType e)&#123;</div><div class="line">	BiTNode *s,*p,*f;</div><div class="line"></div><div class="line">	<span class="comment">//在以T为根指针的二叉排序树中插入记录e</span></div><div class="line">	s=new BiTNode;</div><div class="line">	<span class="function"><span class="title">s</span>-&gt;</span><span class="keyword">data</span>.key=e;</div><div class="line">	<span class="function"><span class="title">s</span>-&gt;</span>lchild=NULL;</div><div class="line">	<span class="function"><span class="title">s</span>-&gt;</span>rchild=NULL;</div><div class="line"></div><div class="line">	<span class="keyword">if</span>(!T)&#123;</div><div class="line">		T=s;</div><div class="line">	&#125;<span class="keyword">else</span>&#123;</div><div class="line">		p=T;</div><div class="line">		<span class="keyword">while</span>(p)&#123;</div><div class="line">			<span class="function"><span class="title">if</span>(e&lt;p-&gt;</span><span class="keyword">data</span>.key)&#123;</div><div class="line">				f=p;</div><div class="line">				<span class="function"><span class="title">p</span>=p-&gt;</span>lchild;</div><div class="line">			&#125;<span class="keyword">else</span>&#123;</div><div class="line">				f=p;</div><div class="line">				<span class="function"><span class="title">p</span>=p-&gt;</span>rchild;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="function"><span class="title">if</span>(e&lt;f-&gt;</span><span class="keyword">data</span>.key)&#123;</div><div class="line">			<span class="function"><span class="title">f</span>-&gt;</span>lchild=s;</div><div class="line">		&#125;<span class="keyword">else</span>&#123;</div><div class="line">			<span class="function"><span class="title">f</span>-&gt;</span>rchild=s;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//查找</span></div><div class="line">bool Search_BST(BiTree T, KeyType kval,BiTree &amp;p,BiTree &amp;f)&#123;</div><div class="line">	p=T;</div><div class="line">	<span class="keyword">while</span>(p)&#123;</div><div class="line">		<span class="function"><span class="title">if</span>(kval==p-&gt;</span><span class="keyword">data</span>.key)&#123;</div><div class="line">			return <span class="literal">true</span>;</div><div class="line">		&#125;<span class="function"><span class="title">else</span> <span class="keyword">if</span>(kval&lt;p-&gt;</span><span class="keyword">data</span>.key)&#123;</div><div class="line">			f=p;</div><div class="line">			<span class="function"><span class="title">p</span>=p-&gt;</span>lchild;</div><div class="line">		&#125;<span class="keyword">else</span>&#123;</div><div class="line">			f=p;</div><div class="line">			<span class="function"><span class="title">p</span>=p-&gt;</span>rchild;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	return <span class="literal">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="6-哈希查找"><a href="#6-哈希查找" class="headerlink" title="6.哈希查找"></a>6.哈希查找</h3><p><strong>介绍：</strong> 在上述的查找中，由于数据元素在线性表中的存储位置是随机的，和关键字无关，因此在查找时，需将给定值和线性表中记录的关键字逐个比较，查找的效率基于历经比较的关键字的个数。设想，若在数据元素的关键字和其存储位置（数组下标）之间建立一个确定的函数关系f，即将关键字为key的记录存储在下标为Hash(key)的位置上，这样在查找关键字等于给定值kval的记录时，仅需直接对给定值进行某种运算，求得记录的存储位置Hash(kval)，而不需要和其他记录的关键字进行比较。按这种方法组织数据，在进行查找时将会有效减少针对关键字的比较次数，也就可以从根本上降低平均查找长度ASL的值。而哈希查找就是通过计算数据元素的存储地址进行查找的一种方法。<br><strong>哈希函数：</strong> Hash(key)称为哈希函数。<br><strong>冲突：</strong> 对不同的关键字key1和key2得到相同的哈希地址（即哈希函数值）Hash(key1)=Hash(key2)的这种现象称为冲突。在设定哈希函数时要考虑不发生冲突，然而实际上不发生冲突的哈希函数极少存在，只能设定对给定的关键字集合冲突尽可能少的哈希函数，在产生冲突时进行再散列，即为那些哈希地址位置已被其他记录占用的记录安排另外的存储位置。因此在建哈希表的时候，不但要设定一个哈希函数，还要设定一个处理冲突的方法。<br><strong>哈希表：</strong> 哈希表是根据设定的哈希函数和处理冲突的方法为一组数据元素建立的一种存储结构。哈希函数又称散列函数，构造哈希表的方法又称散列技术。<br><strong>装填系数：</strong> 假设哈希表的空间大小为m，在表中填入的数据元素数为n，定义a=n/m为哈希表的装填系数，实际应用时，常取a为0.65~0.85.<br><strong>构造哈希函数的方法：</strong><br>（1）除留余数法：取关键字被某个不大于哈希表表长m的数p除后所得余数为哈希地址，即设定哈希函数为Hash(key)=key mod p (p&lt;=m)。通常取p为不大于表长且最接近表长m的素数。如当哈希表表长为1000，可取p=977。<br>（2）平方取中法：取关键字平方后的中间几位为哈希地址，因为一个数的平方值的中间几位和这个数的每一位都相关，则对不同的关键字得到的哈希函数值不易产生冲突。若哈希表表长为1000，则可取关键字平方值的中间3位。<br>（3）折叠法：将关键字分割成位数相同的几部分（最后一部分位数可以不同），然后取这几部分的叠加和（舍去进位）作为哈希地址。当关键字的位数很多且每一位的值都随机出现时，采用这种方法可得到冲突较少的哈希地址。<br>a. 移位叠加：将分割后的每一部分的最低位对齐，然后相加。如key=123456789，H(key)=123+456+789=1368。<br>b. 间界叠加：从一端向另一端沿分割界来回折叠，然后对齐相加。如key=123456789，H(key)=123+654+789=1566。<br><strong>处理冲突的方法：</strong><br>（1）开放地址法<br>从哈希函数求得一个地址序列H[1],H[2],…,H[k]，即哈希表中下标为H[1]，H[2]，H[k-1]的存储空间都已有记录，直至下标H[k]为空（若哈希表不满，必能找到k&lt;=m-1）。即 H[i]=(Hash(key)+d[i]) mod m , Hash(key)为哈希函数，m为哈希表的表长，d[i]为增量序列。<br>增量序列的取法有下列三种：<br>a. d[i]=1,2,3,…,m-1,称为线性探测再散列。这种取法最简单，只要哈希表没填满就总能找到一个空的位置，但容易对之后填入的记录增加冲突。<br>b. d[i]=1², -1², 2², -2²,…,k²,-k²（k&lt;=m/2），称为二次探测再散列。这种取法要求表长m必须是形如4j+3(j=1,2,…)的素数，如7,11,19,23,…等。<br>c. d[i]是一个伪随机序列，称为随机探测再散列。用这种取法时需选择一个伪随机函数产生伪随机数列，且在建表装填和查找时应使用同一个伪随机函数来生成伪随机数列。<br>（2）链地址法<br>将所有key对应的Hash(key)相同的记录存储在同一线性链表中，而哈希表中下标为i的空间存储哈希函数值为i的链表头指针。<br><strong>算法流程：</strong> 哈希表的查找过程和建表过程一致，以开放地址处理冲突线性探测再散列为例。假设哈希函数为Hash(x)，则查找过程为：对给定值kval，求得哈希地址为j=Hash(kval)，若哈希表中下标为j的空间为空，则查找不成功，可将关键字等于kval的记录填入；若表中该空间不空且所填记录的关键字等于kval，则查找成功，否则按建表时设定的散列方法重复计算处理冲突后的各个地址，直至表中相应空间为空或者所填记录的关键字等于kval，前者表示查找不成功，后者查找成功。<br><strong>C++描述：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> NULLKEY=<span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</div><div class="line">	ElemType *elem;</div><div class="line">	<span class="keyword">int</span> count;</div><div class="line">&#125; HashTable;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">Hash</span><span class="params">(<span class="keyword">int</span> kval)</span></span>&#123;   <span class="comment">//除留余数法</span></div><div class="line">	<span class="keyword">return</span> kval%NUM;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Next</span><span class="params">(<span class="keyword">int</span> &amp;p, <span class="keyword">int</span> &amp;c)</span></span>&#123;   <span class="comment">//线性探测再散列</span></div><div class="line">	p=(p+<span class="number">1</span>)%LENGTH;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">HashSearch</span><span class="params">(HashTable H, KeyType kval,<span class="keyword">int</span> &amp;p,<span class="keyword">int</span> &amp;c)</span></span>&#123;</div><div class="line">	<span class="comment">//在开放定址哈希表H中查找关键码为kval的元素，</span></div><div class="line">	<span class="comment">//若查找成功，以p指示待查记录在表中位置,并返回p；否则，以p指示插入位置，并返回-1；</span></div><div class="line">	<span class="comment">//以c计算冲突次数，其初值置0，供建表插入时参考</span></div><div class="line">	p=Hash(kval);   <span class="comment">//求得哈希地址</span></div><div class="line">	<span class="keyword">while</span> (H.elem[p].key != NULLKEY &amp;&amp; (H.elem[p].key != kval))&#123; <span class="comment">//位置中有记录且不等于kval，即有冲突</span></div><div class="line">		Next(p,++c);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span>(H.elem[p].key==kval)&#123;</div><div class="line">		<span class="keyword">return</span> p;</div><div class="line">	&#125;<span class="keyword">else</span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">InsertHash</span><span class="params">(HashTable &amp;H,ElemType e)</span></span>&#123;</div><div class="line">	<span class="keyword">int</span> c=<span class="number">0</span>,j=<span class="number">0</span>;</div><div class="line">	<span class="keyword">if</span>(HashSearch(H,e.key,j,c)!=<span class="number">-1</span>)&#123;</div><div class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">	&#125;<span class="keyword">else</span>&#123;</div><div class="line">		H.elem[j]=e;</div><div class="line">		++H.count;</div><div class="line">		<span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>未完待续~</p>
</div></header></article><section class="reward"> <a href="#" class="btn-reward">打赏</a><div class="reward-wrapper clearfix"><img src="/img/wechat.png"></div></section><div class="comments"><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a>
</noscript></div></div></main><footer class="foot"><div class="foot-copy u-fl">&copy; 2016-2017 Rose Ou</div><menu class="page-menu u-fr"><li class="page-menu__item"><span title="Previous" class="page-menu__link icon-arrow-left page-menu__link--disabled"></span></li><li class="page-menu__item"><a title="Next" href="/2016/07/07/formhtml/" class="page-menu__link icon-arrow-right"></a></li></menu></footer><script>(function(h,g,l,k,j,i){j=h.createElement(g),i=h.getElementsByTagName(g)[0],j.src="//"+l+".disqus.com/"+k+".js",i.parentNode.insertBefore(j,i)})(document,"script","ochukai","embed");
</script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));
ga('create','UA-73840162-1');
ga('send','pageview');
</script><script src="/js/scroller.js"></script><script src="/js/main.js"></script></body></html>