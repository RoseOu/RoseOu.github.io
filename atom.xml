<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>RoseOu&#39;s blog</title>
  <subtitle>Work hard!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-10-07T07:09:27.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Rose Ou</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>提取图像显著性区域</title>
    <link href="http://yoursite.com/2019/10/07/xianzhu/"/>
    <id>http://yoursite.com/2019/10/07/xianzhu/</id>
    <published>2019-10-07T06:01:58.000Z</published>
    <updated>2019-10-07T07:09:27.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="提取图像显著性区域"><a href="#提取图像显著性区域" class="headerlink" title="提取图像显著性区域"></a>提取图像显著性区域</h1><p>实现的效果如下：<br><img src="/images/img/result.png" width="55%" height="55%/">  </p>
<h2 id="一、图像显著性检测"><a href="#一、图像显著性检测" class="headerlink" title="一、图像显著性检测"></a>一、图像显著性检测</h2><p>这里使用的方法来自以下论文。<br>[1] Zhu W, Liang S, Wei Y, et al. Saliency Optimization from Robust Background Detec- tion[C].//Computer Vision and Pattern Recognition. Columbus, OH, USA:IEEE, 2014:2814- 2821</p>
<h3 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h3><p>  在显著性检测中，利用背景先验进行检测是一种有效的方式，即认为图像边界是背景或者可以容易地连接到图像边界的图像块是背景。这样的方法很容易引入前景噪声，且当物体只稍微接触到边界时也可能被判定为背景。<br>  文中提出了一个新颖而可靠的背景判定方法：边界连接度。文中提出的判定表明，仅当图像块所属的区域与图像边界紧密连接时，图像块才是背景。<br>  这种方法描述了图像区域相对于图像边界的空间布局，且具有直观的几何解释，因此在图像内容变化方面是稳定的。   </p>
<h3 id="2、边界连接度"><a href="#2、边界连接度" class="headerlink" title="2、边界连接度"></a>2、边界连接度</h3><h4 id="（1）定义"><a href="#（1）定义" class="headerlink" title="（1）定义"></a>（1）定义</h4><p>  从下图可以观察到，在空间布局上，目标区域与图像边界的连接要比背景区域与图像边界的连接少得多。图像由四个区域组成，从人类的感知来看，绿色区域明显是一个显著目标，因为它更大、更紧凑，而且只略微接触到图像边界。蓝色和白色区域显然是背景，因为它们明显地接触到图像边界。粉红色区域只略微地接触到图像边界，但由于它的大小也很小，看起来更像是一个部分裁剪的对象，因此不是一个显著目标。<br><img src="/images/img/eximg.png" width="45%" height="45%/"><br>  于是，文章提出了一种量化某个区域R与图像边界的连接程度的方法，称为边界连接度。它被定义为<br><img src="/images/img/bndcon.png"><br>   其中Bnd是图像边界块的集合，p是图像块。<br>   边界连接度有直观的几何解释：它是区域R在边界上图像块的周长与区域R的总周长或者说是区域R面积的平方根之比（图上就是区域R在边界上图像块的块数与区域R的总块数的平方根之比）。这里使用面积的平方根来实现比例不变性：在不同的图像补丁分辨率下，该测量保持稳定。如上图，对于背景区域，边界连接度通常较大，而对于目标区域，边界连接度通常较小。<br>   （之所以要取根号，我的理解为，如果图像分辨率不同，那么相应的图像块的面积大小也不同，这样可能会引起误差，比如图上的例子，3/49约等于0.06，34/192约等于0.18，这样看树的连接度低很多，但如果图像被放大了，他们的连接度差别将没那么明显，取根号可以有效防止图像放大带来的副作用。）   </p>
<h4 id="（2）边界连接度公式计算"><a href="#（2）边界连接度公式计算" class="headerlink" title="（2）边界连接度公式计算"></a>（2）边界连接度公式计算</h4><p>  公式（1）中的定义虽然直观，但难以计算。因为图像分割本身是一个具有挑战性且尚未解决的问题。使用硬分割不仅涉及到算法、参数选择的难题，而且还会沿区域边界引入不希望出现的不连续伪影。<br>  文章指出，准确的硬图像分割是不必要的。文中提出了一种“软”方法，首先使用SLIC方法将图像抽象为一组组几乎规则的超像素块的集合。超级像素结果示例如下图（a）所示。<br><img src="/images/img/slic.png"><br>  然后，连接所有相邻的超像素块，将它们之间的权重dapp指定为它们的平均颜色在CIE-Lab颜色空间中的欧几里德距离，来构造一个无向加权图。(CIE-Lab是CIE的一个颜色系统，表色体系，可用于确定某个颜色的数值信息。)<br>  任意两个超像素块之间的测地线距离dgeo（p；q）定义为：在图上，两个超像素之间沿最短路径累积的权重dapp。（dgeo我理解为两个超像素块的颜色相似度或者说颜色相差度）。方便起见，定义dgeo（p；p）=0。（测地线，即曲面上两点间距离最短的线）<br><img src="/images/img/dgeo.png"><br>  定义每个超级像素块p所属区域的面积为<br><img src="/images/img/area.png"><br>  公式利用高斯权重函数将两个超像素块之间的距离（或者说相似度）映射到（0，1）之间，当两个超像素块更相似，则其映射的值更倾向于1。也就是，公式判断p与每一个pi的相似度，然后将每一个相似度相加，最后就是p所属区域的面积。<br>  同样地，把p所属区域的触碰到图像边界的超像素块的长度定义为<br><img src="/images/img/lenbnd.png"><br>  其中，超像素块若在图像边界上，为1，否则为0。<br>  （这里的长度实际上也是面积，因为是像素块。这里的p应为图像块碰到边界的）<br>  最后，以类似于式（1）来计算边界连接性<br><img src="/images/img/bndcon1.png">   </p>
<h3 id="3、背景加权对比度——使用边界连接度来改善对比度计算"><a href="#3、背景加权对比度——使用边界连接度来改善对比度计算" class="headerlink" title="3、背景加权对比度——使用边界连接度来改善对比度计算"></a>3、背景加权对比度——使用边界连接度来改善对比度计算</h3><p>  通常，传统的对比度计算为：某像素与所有其他像素的外观距离（即之前说过的相似度）乘以空间距离之和，即<br><img src="/images/img/ctr.png"><br>  其中，<img src="/images/img/wspa.png">。dspa（p,pi）是超像素块p和pi的中心之间的空间距离。<br>  文章引入背景概率wbgi作为一个新的加权项来扩展式（6）。使用超像素块pi的边界连通度来值映射出概率wbgi。当边界连接性较大时，它接近于1；当边界连接性较小时，它接近于0。定义是<br><img src="/images/img/wbgi.png"><br>  增强的对比度，称为背景加权对比度，定义为<br><img src="/images/img/wctr.png">   </p>
<h3 id="4、结果对比"><a href="#4、结果对比" class="headerlink" title="4、结果对比"></a>4、结果对比</h3><p>  文章将其他论文的算法与本文的算法进行对比，包括SF、MR、GS算法。<br><img src="/images/img/xianzhu.png" width="75%" height="75%/"> </p>
<p>以上，为论文中的显著性检测的算法。<br>下载了论文的代码，发现它是MATLAB和CPP混编的，而且代码比较久远，其中有许多问题，我一个个debug，最后还是跑了起来，最后得到的结果。<br>得到经过图像显著性检测的灰度图以后，需要进行图像二值化。 </p>
<h3 id="5、关于论文的参考资料："><a href="#5、关于论文的参考资料：" class="headerlink" title="5、关于论文的参考资料："></a>5、关于论文的参考资料：</h3><p><a href="https://blog.csdn.net/yxz3024/article/details/79913449" target="_blank" rel="noopener">https://blog.csdn.net/yxz3024/article/details/79913449</a><br><a href="https://blog.csdn.net/dayenglish/article/details/51275128#commentsedit" target="_blank" rel="noopener">https://blog.csdn.net/dayenglish/article/details/51275128#commentsedit</a><br><a href="https://www.cnblogs.com/ariel-dreamland/p/9282905.html" target="_blank" rel="noopener">https://www.cnblogs.com/ariel-dreamland/p/9282905.html</a><br><a href="https://blog.csdn.net/zhangwenjuan1995/article/details/95043177" target="_blank" rel="noopener">https://blog.csdn.net/zhangwenjuan1995/article/details/95043177</a>     </p>
<h2 id="二、图像二值化"><a href="#二、图像二值化" class="headerlink" title="二、图像二值化"></a>二、图像二值化</h2><p>图像的二值化，就是将图像上的像素点的灰度值设置为0或255，使整个图像呈现出只有黑色和白色的视觉效果。我们可以通过设置一个阈值，判断图像的像素点的灰度值大于阈值还是小于阈值，从而判断将其设置为255还是0。那么这个阈值的设置就尤为重要。   </p>
<h3 id="1、全局阈值（单阈值）"><a href="#1、全局阈值（单阈值）" class="headerlink" title="1、全局阈值（单阈值）"></a>1、全局阈值（单阈值）</h3><h4 id="（1）最简单的方法"><a href="#（1）最简单的方法" class="headerlink" title="（1）最简单的方法"></a>（1）最简单的方法</h4><p>原理：将阈值设置为127，如果像素点的灰度值小于127，则将其灰度值设置为0，如果像素点的灰度值大于127，则将其灰度值设置为255。<br>优点：简单，计算量少速度快。<br>缺点：首先阈值为127没有任何理由可以解释，其次完全不考虑图像的像素分布情况与像素值特征，可能导致部分对象像素或者背景像素丢失。<br>改进：可将阈值改为所有像素点的灰度值的平均值。   </p>
<h4 id="（2）双峰法"><a href="#（2）双峰法" class="headerlink" title="（2）双峰法"></a>（2）双峰法</h4><p>原理：把图像看作由前景和背景组成，在灰度直方图上，前景和背景都形成一个高峰，在双峰之间的最低谷处就是图像的阈值所在。假如一张图像的直方图如下所示：<br><img src="/images/img/histogram.png" width="55%" height="55%/"><br>从图中我们可以看到有两个顶峰，将顶峰记为H1和H2，他们对应的灰度值分别为T1和T2，那么双峰法的思想就是要找到图像两个顶峰之间的最低值作为阈值。简单来说就是，在一张图像中，灰度值为T1和T2的像素点是最多的，在[T1,T2]的灰度值范围之间，像素点最少的灰度值，就是阈值。<br>优点：该方法适用于直方图有两个顶峰的图像，即背景与前景颜色差别较大的图像。<br>缺点：不适合直方图曲线平坦或者只有一个顶峰的图像。    </p>
<h4 id="（3）迭代法"><a href="#（3）迭代法" class="headerlink" title="（3）迭代法"></a>（3）迭代法</h4><p>原理：首先初始化一个阈值T0，然后按照某种策略通过迭代不断更新这一阈值，直到满足给定的约束条件为止。通过迭代方法选择阈值的计算方法如下：<br>（1）选择图像所有像素点的灰度值的平均值作为初始阈值T0。<br>（2）对于灰度值小于等于T0的像素点，计算出他们的灰度值的平均值T1；对于灰度值大于T0的像素点，计算出他们的灰度值的平均值T2。<br>（3）新的阈值为T=（T1+T2）/2。<br>（4）比较T和T0，若相等，则返回T，T即为迭代法得到的阈值; 否则设T0=T，重复步骤（1）~（3），直至T和T0相等。<br>优点：用迭代法所获得的阈值进行二值化的图象效果良好，因为基于迭代的阈值能区分出图像的前景和背景的主要区域所在。<br>缺点：但在图像的细微处（即图像的浅色线条）还没有很好的区分度。而对于某些特定图象，微小数据的变化却会引起分割效果的巨大改变。   </p>
<h4 id="（4）otsu法（最大类间方差法-大律法）"><a href="#（4）otsu法（最大类间方差法-大律法）" class="headerlink" title="（4）otsu法（最大类间方差法/大律法）"></a>（4）otsu法（最大类间方差法/大律法）</h4><p>原理：用阈值将原图像分成前景、背景两类，当取最佳阈值时，背景应该与前景差别最大，在otsu算法中衡量差别的标准就是最大类间方差。基本思想是，从0到255循环选取灰度t作为阈值，根据阈值把图像分为两类，然后计算两类之间的方差，使类间方差达到最大时的阈值，即为所求最佳阈值。<br>otsu的公式推导：记t为前景与背景的分割阈值，前景点数占图像比例为w0，平均灰度为u0；背景点数占图像比例为w1，平均灰度为u1。<br>则图像的总平均灰度为：u=w0*u0+w1*u1。<br>前景和背景图象的方差：g=w0*(u0-u)*(u0-u)+w1*(u1-u)*(u1-u)=w0*w1*(u0-u1)*(u0-u1),此公式为方差公式。<br>当方差g最大时，可以认为此时前景和背景差异最大，此时选取的灰度t是最佳阈值。<br>优点：类间方差法对噪音和目标大小十分敏感，它仅对类间方差为单峰的图像产生较好的分割效果。<br>缺点：当目标与背景的大小比例悬殊时（例如受光照不均、反光或背景复杂等因素影响），类间方差准则函数可能呈现双峰或多峰，此时效果不好，但是类间方差法是用时最少的。    </p>
<h3 id="2、自适应阈值（多阈值）"><a href="#2、自适应阈值（多阈值）" class="headerlink" title="2、自适应阈值（多阈值）"></a>2、自适应阈值（多阈值）</h3><p>上面所有选取阈值的方法，都是对图像上的每个像素使用相等的阈值。<br>但在实际情况中，当照明不均匀、有突发噪声或者背景变化较大时，对于整幅图像将没有合适的单一阈值，如果仍采用单一的阈值去处理每一个像素，可能会将目标和背景区域错误划分。<br>而自适应阈值，就是将图像中的每个像素设置可能不一样的阈值，根据像素的邻域块的像素值分布来确定该像素位置上的阈值。<br>基本原理：规定一个区域大小，对每个像素确定以其自身为中心的一个区域（即其邻域），计算区域内所有像素值的平均值（或者区域内最大和最小像素值的平均值，或者区域内内所有像素值的高斯卷积），将其作为该像素点的阈值。<br>优点：每个像素的阈值不是都一样的，而是由其周围邻域像素的分布来决定的。亮度较高的图像区域的阈值通常会较高，而亮度较低的图像区域的阈值则会相适应地变小。<br>缺点：计算较为复杂。   </p>
<h3 id="3、几种方法的效果"><a href="#3、几种方法的效果" class="headerlink" title="3、几种方法的效果"></a>3、几种方法的效果</h3><p><img src="/images/img/yuzhi.png" width="75%" height="75%/">  </p>
<h3 id="4、关于图像二值化的参考资料："><a href="#4、关于图像二值化的参考资料：" class="headerlink" title="4、关于图像二值化的参考资料："></a>4、关于图像二值化的参考资料：</h3><p><a href="https://blog.csdn.net/u011600592/article/details/75044250" target="_blank" rel="noopener">https://blog.csdn.net/u011600592/article/details/75044250</a><br><a href="https://baike.baidu.com/item/otsu/16252828" target="_blank" rel="noopener">https://baike.baidu.com/item/otsu/16252828</a><br><a href="https://blog.csdn.net/weixin_34163553/article/details/85991870" target="_blank" rel="noopener">https://blog.csdn.net/weixin_34163553/article/details/85991870</a><br><a href="https://blog.csdn.net/qq_44262417/article/details/89283484" target="_blank" rel="noopener">https://blog.csdn.net/qq_44262417/article/details/89283484</a><br><a href="https://blog.csdn.net/wrightman/article/details/39204265" target="_blank" rel="noopener">https://blog.csdn.net/wrightman/article/details/39204265</a><br><a href="https://blog.csdn.net/zhu_hongji/article/details/80967776" target="_blank" rel="noopener">https://blog.csdn.net/zhu_hongji/article/details/80967776</a><br><a href="https://blog.csdn.net/u014737138/article/details/80379309" target="_blank" rel="noopener">https://blog.csdn.net/u014737138/article/details/80379309</a><br><a href="https://blog.csdn.net/whl970831/article/details/99706730" target="_blank" rel="noopener">https://blog.csdn.net/whl970831/article/details/99706730</a><br><a href="https://blog.csdn.net/fly108108/article/details/81104330#4%E3%80%81%C2%A0%E8%BF%AD%E4%BB%A3%E9%98%88%E5%80%BC%E5%88%86%E5%89%B2" target="_blank" rel="noopener">https://blog.csdn.net/fly108108/article/details/81104330#4%E3%80%81%C2%A0%E8%BF%AD%E4%BB%A3%E9%98%88%E5%80%BC%E5%88%86%E5%89%B2</a><br><a href="https://blog.csdn.net/cp32212116/article/details/44487913" target="_blank" rel="noopener">https://blog.csdn.net/cp32212116/article/details/44487913</a><br><a href="https://blog.csdn.net/bravebean/article/details/51374066" target="_blank" rel="noopener">https://blog.csdn.net/bravebean/article/details/51374066</a> </p>
<h2 id="三、根据二值化后的图像得到显著性区域的包围矩形及其坐标"><a href="#三、根据二值化后的图像得到显著性区域的包围矩形及其坐标" class="headerlink" title="三、根据二值化后的图像得到显著性区域的包围矩形及其坐标"></a>三、根据二值化后的图像得到显著性区域的包围矩形及其坐标</h2><p>使用cv2.boundingRect()方法即可。<br>结果：<br><img src="/images/img/rect.png" width="75%" height="75%/"><br>资料：<br><a href="https://www.cnblogs.com/mrfri/p/8550328.html" target="_blank" rel="noopener">https://www.cnblogs.com/mrfri/p/8550328.html</a>   </p>
<h2 id="四、裁剪图像得到原图像的显著性区域"><a href="#四、裁剪图像得到原图像的显著性区域" class="headerlink" title="四、裁剪图像得到原图像的显著性区域"></a>四、裁剪图像得到原图像的显著性区域</h2><p>根据获得的包围矩形坐标，利用矩形的索引即可。<br>结果：<br><img src="/images/img/cut.png" width="75%" height="75%/">     </p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;提取图像显著性区域&quot;&gt;&lt;a href=&quot;#提取图像显著性区域&quot; class=&quot;headerlink&quot; title=&quot;提取图像显著性区域&quot;&gt;&lt;/a&gt;提取图像显著性区域&lt;/h1&gt;&lt;p&gt;实现的效果如下：&lt;br&gt;&lt;img src=&quot;/images/img/result.p
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>迷宫生成与求解</title>
    <link href="http://yoursite.com/2017/05/09/%E8%BF%B7%E5%AE%AB%E7%94%9F%E6%88%90%E4%B8%8E%E6%B1%82%E8%A7%A3/"/>
    <id>http://yoursite.com/2017/05/09/迷宫生成与求解/</id>
    <published>2017-05-09T02:22:22.000Z</published>
    <updated>2017-05-12T14:03:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍如何通过回溯随机生成单迷宫并通过摸墙算法对生成的迷宫找到通往出口的路线。<br>以下的讨论只给出核心代码，完整代码可到我的<a href="https://github.com/RoseOu/Daily_Exercise/tree/master/MazeLab" target="_blank" rel="noopener">Github</a>。</p>
<h2 id="迷宫生成"><a href="#迷宫生成" class="headerlink" title="迷宫生成"></a>迷宫生成</h2><p><strong>回溯算法：</strong> 回溯算法也叫试探法，其基本思想是，从一条路往前走，能进则进，不能进则退回来，换一条路再试。</p>
<p><strong>单迷宫：</strong> 这里我所生成的迷宫是单迷宫，也就是说它是简单连通图并且没有回路（即实际上它是树结构）。这样的迷宫，里面不存在一堵独立的墙（即墙周围都是通道），也不存在一个独立被分隔开的单元（即单元周围都是墙）。</p>
<p><strong>生成迷宫的步骤：</strong></p>
<ol>
<li>一开始所有单元周围都是墙。</li>
<li>随机选择一个单元作为当前起点，并将起点标记为已访问。</li>
<li>在这个起点的四面墙中随机选择一面墙。如果被这面墙分隔的两个单元不连通，并且与这面墙相邻的另外一个单元未曾访问过，则拆掉这面墙，并将与这面墙相邻的另外一个单元作为下一个当前起点，并将其标记为已访问。如果当前起点周围所有相邻的单元都已访问过，则回溯到上一个起点再次选择另外一面墙，重复步骤。</li>
<li>当回溯到最开始所选择的起点时，算法结束，迷宫生成完成。</li>
</ol>
<p><strong>C++语言实现：</strong><br>首先，用一个二维数组存放迷宫的连通状态，即存放迷宫每个单元里连通（没有墙）的方向，并将其全部置0，表示迷宫的初始状态为所有单元相互都不连通，即所有单元周围都是墙。<br><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> **<span class="keyword">grid</span>;   <span class="comment">//存放迷宫连通状态</span></span><br><span class="line"><span class="keyword">grid</span>=new <span class="keyword">int</span> *[WIDTH];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;WIDTH;i++)&#123;</span><br><span class="line">	<span class="keyword">grid</span>[i]=new <span class="keyword">int</span>[HEIGHT];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;WIDTH;i++)&#123;     <span class="comment">//全部置0</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;HEIGHT;j++)&#123;</span><br><span class="line">		<span class="keyword">grid</span>[i][j]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而四个方向我们可以用一个枚举类型表示。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enum &#123;N=<span class="number">1</span>,E=<span class="number">4</span>,S=<span class="number">2</span>,W=<span class="number">8</span>&#125;;</span><br></pre></td></tr></table></figure></p>
<p>之所以用N=1,E=4,S=2,W=8表示而不是简单地用N=1,E=2,S=3,W=4表示，是因为迷宫中的单元很有可能会有2个方向是连通的，那样存放连通状态的grid在该单元中就要存放2个方向，而1、2、4、8在二进制表示中分别为0001、0010、0100、1000，1不重复出现在相同的位上，只要将两个方向进行“或”操作，就可以同时存储起来。</p>
<p>然后，随机选择一个单元作为当前起点。<br><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">srand((<span class="keyword">int</span>)<span class="keyword">time</span>(<span class="number">0</span>));   <span class="comment">//生成随机数种子</span></span><br><span class="line">sx=<span class="keyword">rand</span>() % WIDTH;     <span class="comment">//随机选择起点(sx,sy)</span></span><br><span class="line">sy=<span class="keyword">rand</span>() % HEIGHT;</span><br></pre></td></tr></table></figure></p>
<p>接下来，在这个起点的四面墙中随机选择一面墙，即从四个方向中随机选择一个方向。通过回溯生成迷宫时，一个单元可能会多次随机选择方向，并且不会重复选择，而在每个单元中最多只会随机选择4次墙，所以我们可以用一个数组directions[4]来存放选择方向的顺序，并且对于每个单元都重置方向顺序，从而达到随机选择方向而又不重复选择。<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int reset_directions(int *directions, int <span class="built_in">size</span>) &#123;</span><br><span class="line">	<span class="keyword">for</span>(int <span class="built_in">i</span>=<span class="number">0</span>; <span class="built_in">i</span>&lt;(<span class="built_in">size</span> - <span class="number">1</span>); <span class="built_in">i</span>++) &#123;</span><br><span class="line">		int r = <span class="built_in">i</span> + (<span class="built_in">rand</span>() <span class="comment">% (size - i));</span></span><br><span class="line">		int temp = directions[<span class="built_in">i</span>];</span><br><span class="line">		directions[<span class="built_in">i</span>] = directions[r];</span><br><span class="line">		directions[r] = temp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接着就是拆墙前进、不断重复步骤和回溯。重复和回溯可通过递归实现，拆墙的过程实际上就是将墙相对于单元的方向设置为连通，用数组grid存放作为单元的连通的方向。朝不同方向前进会造成不同的坐标变化，可以用一个数组DX[9]和一个数组DY[9]来存放不同方向的坐标变化（之所以数组大小为9是因为W=8），而后前进到下一个要走单元时，由于下一个要走的单元的连通方向与当前单元的连通方向是相反的，我们可以用一个数组OPPOSITE[9]来存放每个方向的相反方向。<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">OPPOSITE[N]</span> = S<span class="comment">;    //反方向</span></span><br><span class="line"><span class="attr">OPPOSITE[E]</span> = W<span class="comment">;</span></span><br><span class="line"><span class="attr">OPPOSITE[S]</span> = N<span class="comment">;</span></span><br><span class="line"><span class="attr">OPPOSITE[W]</span> = E<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">DX[N]</span> = <span class="number">0</span><span class="comment">;</span></span><br><span class="line"><span class="attr">DX[E]</span> = <span class="number">1</span><span class="comment">;</span></span><br><span class="line"><span class="attr">DX[S]</span> = <span class="number">0</span><span class="comment">;</span></span><br><span class="line"><span class="attr">DX[W]</span> = -<span class="number">1</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">DY[N]</span> = -<span class="number">1</span><span class="comment">;</span></span><br><span class="line"><span class="attr">DY[E]</span> = <span class="number">0</span><span class="comment">;</span></span><br><span class="line"><span class="attr">DY[S]</span> = <span class="number">1</span><span class="comment">;</span></span><br><span class="line"><span class="attr">DY[W]</span> = <span class="number">0</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>拆墙前进、不断重复步骤和回溯的算法如下：<br><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> destroy_wall(<span class="keyword">int</span> cx, <span class="keyword">int</span> cy, <span class="keyword">int</span> **<span class="keyword">grid</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> nx, ny;</span><br><span class="line">    <span class="keyword">int</span> directions[<span class="number">4</span>] = &#123;N, E, S, W&#125;;</span><br><span class="line"></span><br><span class="line">    reset_directions(directions, <span class="number">4</span>); <span class="comment">//重置方向顺序</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        nx = cx + DX[directions[i]];  <span class="comment">//下一个要走单元（即当前起点与选择的墙相隔的单元）</span></span><br><span class="line">        ny = cy + DY[directions[i]];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( ((nx &lt; WIDTH) &amp; (nx &gt;= <span class="number">0</span>)) &amp; ((ny &lt; HEIGHT) &amp; (ny &gt;= <span class="number">0</span>)) ) &#123; <span class="comment">//如果下一个单元在grid里，没有超出范围</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">grid</span>[nx][ny] == <span class="number">0</span>) &#123;  <span class="comment">//如果下一个要走的单元未被访问</span></span><br><span class="line">                <span class="keyword">grid</span>[cx][cy] = (<span class="keyword">int</span>)((<span class="keyword">int</span>)<span class="keyword">grid</span>[cx][cy] | (<span class="keyword">int</span>)directions[i]);  <span class="comment">//拆墙，即存放连通的方向</span></span><br><span class="line">                <span class="keyword">grid</span>[nx][ny] = (<span class="keyword">int</span>)((<span class="keyword">int</span>)<span class="keyword">grid</span>[nx][ny] | (<span class="keyword">int</span>)OPPOSITE[directions[i]]); <span class="comment">//下一个要走的单元的连通方向为当前单元的连通方向的相反方向</span></span><br><span class="line">                destroy_wall(nx, ny, <span class="keyword">grid</span>);  <span class="comment">//重复步骤</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>过程分析：</strong><br>下面通过分析一个实际生成的迷宫的过程来说明。</p>
<p>首先，生成的迷宫以及其最终的连通状态grid如下：</p>
<center><img src="/images/maze/grid.png"></center>

<p>生成迷宫的过程如下：</p>
<p><center><img src="/images/maze/process.png"><center></center></center></p>
<p>过程分析如下：</p>
<p><center><img src="/images/maze/p1.jpg"><center></center></center></p>
<p><center><img src="/images/maze/p2.jpg"><center></center></center></p>
<p>整个迷宫生成回溯的过程如下：<br><img src="/images/maze/迷宫生成3.gif"></p>
<h2 id="迷宫求解"><a href="#迷宫求解" class="headerlink" title="迷宫求解"></a>迷宫求解</h2><p><strong>摸墙算法：</strong>单迷宫是只有一种走法的迷宫。对于单迷宫而言，有一种万能的破解方法，即沿着某一面墙壁走。在走的时候，左（右）手一直摸着左（右）边的墙壁，这种方法可能费时最长，也可能会使你走遍迷宫的每一个角落和每一条死路，但你绝不会永远困在里面。<br>就像这样：</p>
<p><center><img src="/images/maze/wallmaze.png"><img src="/images/maze/wallmaze1.png"><center></center></center></p>
<p><strong>右手摸墙算法流程：</strong></p>
<p><center><img src="/images/maze/wall.png"><center></center></center></p>
<p><strong>C++语言实现：</strong></p>
<p>首先，我们可以设置righthand为右手的方向，用一个FACE[9]数组存放右手在不同方向时人所面向的方向，用一个TURNLEFT[9]数组存放右手在不同方向时转左之后的方向，用一个TURNRIGHT[9]数组存放右手在不同方向时转右之后的方向。<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">FACE[N]</span>=W<span class="comment">;</span></span><br><span class="line"><span class="attr">FACE[E]</span>=N<span class="comment">;</span></span><br><span class="line"><span class="attr">FACE[S]</span>=E<span class="comment">;</span></span><br><span class="line"><span class="attr">FACE[W]</span>=S<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">TURNRIGHT[N]</span>=E<span class="comment">;</span></span><br><span class="line"><span class="attr">TURNRIGHT[E]</span>=S<span class="comment">;</span></span><br><span class="line"><span class="attr">TURNRIGHT[S]</span>=W<span class="comment">;</span></span><br><span class="line"><span class="attr">TURNRIGHT[W]</span>=N<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">TURNLEFT[N]</span>=W<span class="comment">;</span></span><br><span class="line"><span class="attr">TURNLEFT[E]</span>=N<span class="comment">;</span></span><br><span class="line"><span class="attr">TURNLEFT[S]</span>=E<span class="comment">;</span></span><br><span class="line"><span class="attr">TURNLEFT[W]</span>=S<span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>现在我默认将左上角设为入口，右下角设为出口，并默认一开始把右手放在西边。像这样：</p>
<p><center><img src="/images/maze/entry.png"><center></center></center></p>
<p>右手摸墙求解迷宫的算法如下：<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">void solve_maze(int **grid,int **maze)&#123;</span><br><span class="line">    int righthand=W;</span><br><span class="line">    int cx=<span class="number">0</span>,cy=<span class="number">0</span>,nx,ny;</span><br><span class="line"></span><br><span class="line">    maze[cx][cy]=<span class="number">1</span>;  <span class="comment">//maze用来存放迷宫求解的路径顺序</span></span><br><span class="line">    int <span class="built_in">flag</span>=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>((cx == (WIDTH-<span class="number">1</span>)) &amp;&amp; (cy == (HEIGHT-<span class="number">1</span>)) &amp;&amp; (grid[cx][cy] &amp; righthand) == <span class="number">0</span>)&#123; <span class="comment">//当处于右下角的单元并且右手边有墙时即到出口</span></span><br><span class="line">            maze[cx][cy]=<span class="built_in">flag</span>;</span><br><span class="line">            <span class="built_in">flag</span>++;       <span class="comment">//每前进一步，flag加1，从而将路径顺序存储进maze</span></span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((grid[cx][cy] &amp; righthand) !=  <span class="number">0</span>)&#123;  <span class="comment">//当右侧无墙</span></span><br><span class="line">            righthand=TURNRIGHT[righthand];   <span class="comment">//右转90度</span></span><br><span class="line">            maze[cx][cy]=<span class="built_in">flag</span>;</span><br><span class="line">            <span class="built_in">flag</span>++;</span><br><span class="line">            cx=cx+DX[<span class="built_in">FACE</span>[righthand]];     <span class="comment">//前进一步</span></span><br><span class="line">            cy=cy+DY[<span class="built_in">FACE</span>[righthand]];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;                               <span class="comment">//右侧有墙</span></span><br><span class="line">            <span class="keyword">if</span>((grid[cx][cy] &amp; <span class="built_in">FACE</span>[righthand]) !=  <span class="number">0</span>)&#123;   <span class="comment">//前方无墙</span></span><br><span class="line">                maze[cx][cy]=<span class="built_in">flag</span>;</span><br><span class="line">                <span class="built_in">flag</span>++;</span><br><span class="line">                cx=cx+DX[<span class="built_in">FACE</span>[righthand]];    <span class="comment">//前进一步</span></span><br><span class="line">                cy=cy+DY[<span class="built_in">FACE</span>[righthand]];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                righthand=TURNLEFT[righthand];   <span class="comment">//左转90度</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里要注意，并不是当人处于右下角的单元就是走到了出口，有可能人只是摸着上方的墙经过右下角的单元。</p>
<p>把上述例子生成的迷宫求解：</p>
<p><center><img src="/images/maze/grid.png"><center></center></center></p>
<p>输出maze里所存放的路径顺序：</p>
<p><center><img src="/images/maze/solve.png"><center></center></center></p>
<p>由于一个单元可能会经过两次，所以路径会叠加，这样看就比较直观了：<br><img src="/images/maze/迷宫求解3.gif"></p>
<p>因为我比较胖，要霸占半条路。。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍如何通过回溯随机生成单迷宫并通过摸墙算法对生成的迷宫找到通往出口的路线。&lt;br&gt;以下的讨论只给出核心代码，完整代码可到我的&lt;a href=&quot;https://github.com/RoseOu/Daily_Exercise/tree/master/MazeLab&quot;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>查找算法总结</title>
    <link href="http://yoursite.com/2017/04/28/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2017/04/28/查找算法/</id>
    <published>2017-04-28T06:01:58.000Z</published>
    <updated>2017-04-28T10:07:53.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、查找算法的相关概念"><a href="#一、查找算法的相关概念" class="headerlink" title="一、查找算法的相关概念"></a>一、查找算法的相关概念</h2><p><strong>关键字的定义：</strong> 关键字是数据元素中某个数据项的值，用它可以标识一个数据元素。<br><strong>查找的定义：</strong> 用关键字标识数据元素，查找时根据给定的值，在表中确定一个关键字的值等于给定值的记录或数据元素。<br><strong>查找算法的分类：</strong><br>(1).无序查找和有序查找：无序查找即被查找数列有序无序均可.有序查找即被查找数列必须为有序数列。<br>(2).静态查找和动态查找：静态或者动态都是针对查找表而言的。动态表指查找表中有删除和插入操作的表。<br><strong>平均查找长度（ASL）：</strong> 查找过程中先后和给定值进行比较的数据元素的关键字个数的期望值，称为查找算法在查找成功时的平均查找长度。对于含有n个数据元素的查找表，查找成功的平均查找长度为：<strong>ASL=∑Pi*Ci (i=1,2,3,…,n)</strong>。<br>Pi：查找表中第i个数据元素的概率,且∑Pi=1（i=1,2,3,…,n）<br>Ci：找到第i个数据元素（其关键字等于给定值）时和给定值进行过比较的关键字的个数，显然，Ci的值随查找过程的不同而不同。</p>
<h2 id="二、六种查找算法"><a href="#二、六种查找算法" class="headerlink" title="二、六种查找算法"></a>二、六种查找算法</h2><p>以下所有算法讨论涉及的数据元素统一定义为如下描述的类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> KeyType;  <span class="comment">//关键字类型以int为例</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    KeyType key;</span><br><span class="line">&#125; ElemType;</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong> 每个算法只给出核心代码，完整代码请到我的<a href="https://github.com/RoseOu/Daily_Exercise/tree/master/algorithms/search_al" target="_blank" rel="noopener">Github</a>。</p>
<h3 id="1-顺序查找"><a href="#1-顺序查找" class="headerlink" title="1.顺序查找"></a>1.顺序查找</h3><p><strong>介绍：</strong> 顺序查找也称为线形查找，属于无序查找算法。<br><strong>算法思想：</strong> 从线形表的第一个元素的关键字起，依次和给定值进行比较，若某个关键字与给定值相等，则查找成功；反之，若直到扫描结束其关键字和给定值比较都不相等，则表明表中没有所查的记录，查找失败。<br><img src="/images/search_al/sqsearch.gif"><br><strong>C++描述：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType *elem;</span><br><span class="line">    <span class="keyword">int</span> length;  <span class="comment">//表中数据元素个数</span></span><br><span class="line">&#125; SSTable;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SqSearch</span><span class="params">(SSTable ST, KeyType kval)</span></span>&#123; <span class="comment">//kval为需要查找的给定值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;ST.length+<span class="number">1</span>;i++)&#123;  <span class="comment">//依次和给定值进行比较</span></span><br><span class="line">        <span class="keyword">if</span> (ST.elem[i].key==kval)&#123;  <span class="comment">//若某个元素的关键字与给定值相等，则查找成功</span></span><br><span class="line">            <span class="keyword">return</span> i;    <span class="comment">//返回数据元素所在的顺序</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">//直到扫描结束仍然没有数据元素的关键字与给定值相等，查找失败，返回0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于在循环条件中必须加上不使循环变量出界的判别，那么当数据元素个数超过1000时，因判出界操作的时间消耗很可观，它将使整个算法的执行时间几乎增加一倍，为此，可类似于插入排序的算法，在数组的“0下标”处增设“哨兵”，并令查找过程自最后一个元素的关键字开始。<br><strong>C++描述：</strong></p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int SqSearch(SSTable ST, KeyType kval)&#123;</span><br><span class="line">    int <span class="built_in">i</span>;</span><br><span class="line">    ST.elem[<span class="number">0</span>].key=kval;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">i</span>=ST.<span class="built_in">length</span>;ST.elem[<span class="built_in">i</span>].key!=kval;--<span class="built_in">i</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">i</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>平均查找长度：</strong> 当查找成功时，<strong>ASL = 1/n(1+2+3+…+n) = (n+1)/2</strong>。<br><strong>时间复杂度分析：</strong> 当查找不成功时，需要n+1次比较，所以时间复杂度为<strong>O(n)</strong>。</p>
<h3 id="2-折半查找"><a href="#2-折半查找" class="headerlink" title="2.折半查找"></a>2.折半查找</h3><p><strong>介绍：</strong> 也称二分查找，属于有序查找算法。数据元素必须是有序的，如果是无序的则要先进行排序操作。<br><strong>算法思想：</strong> 用给定值先与中间数据元素的关键字比较，中间的数据元素把线形表分成两个子表，若相等则查找成功；若不相等，再根据给定值与该中间数据元素关键字的比较结果确定下一步查找哪个子表，这样逐步缩小范围，直至找到该记录，或者当查找区间缩小到0也没有找到等于给定值的关键字为止。<br><img src="/images/search_al/bisearch.gif"><br><strong>C++描述：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType *elem;</span><br><span class="line">    <span class="keyword">int</span> length;  <span class="comment">//表中数据元素个数</span></span><br><span class="line">&#125; SSTable;</span><br><span class="line"></span><br><span class="line"><span class="comment">//非递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinarySearch</span><span class="params">(SSTable ST, KeyType kval)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low, high, mid;</span><br><span class="line">    low = <span class="number">1</span>;</span><br><span class="line">    high = ST.length;</span><br><span class="line">    <span class="keyword">while</span>(low&lt;=high)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(ST.elem[mid].key &gt; kval)&#123;</span><br><span class="line">            high = mid<span class="number">-1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ST.elem[mid].key &lt; kval)&#123;</span><br><span class="line">            low = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        	<span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinarySearch</span><span class="params">(SSTable ST, KeyType kval, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = low+(high-low)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(ST.elem[mid].key &gt; kval)&#123;</span><br><span class="line">        <span class="keyword">return</span> BinarySearch(ST, kval, low, mid<span class="number">-1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ST.elem[mid].key &lt; kval)&#123;</span><br><span class="line">        <span class="keyword">return</span> BinarySearch(ST, kval, mid+<span class="number">1</span>, high);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>平均查找长度：</strong> <strong>ASL = ((n+1)/n * log(n+1))-1</strong>。<br>对于任意表长n大于50的有序表，其折半查找的平均查找长度近似为：ASL ≈ log(n+1)-1。<br>可以通过构造二叉判定树计算，如：<br><img src="/images/search_al/bisearchasl.jpeg"><br><strong>时间复杂度分析：</strong> 最坏情况下，关键词比较次数为<strong>log(n+1)</strong>，且期望时间复杂度为<strong>O(logn)</strong>。<br><strong>注意：</strong> 可见折半查找的效率好于顺序查找，特别在表长较大时，其差别更大。但折半查找的前提条件是需要有序表顺序存储，对于静态查找表，一次排序后不再变化，折半查找能得到不错的效率。但对于需要频繁执行插入或删除操作的数据集来说，维护有序的排序会带来不小的工作量，那就不建议使用。</p>
<h3 id="3-分块查找"><a href="#3-分块查找" class="headerlink" title="3.分块查找"></a>3.分块查找</h3><p><strong>介绍：</strong> 分块查找又称索引顺序查找，实际上它是顺序查找的一种改进方法。其性能介于顺序查找和折半查找之间，它适合对“分块有序”的数据元素进行查找操作。<br><strong>算法思想：</strong> 将n个数据元素按”分块有序”划分为m块（m ≤ n），所谓“分块有序”是指数据元素可按其关键字的大小分成若干“块”，且“前一块”中的最大关键字小于“后一块”中的最小关键字，而各块内部的数据元素不一定有序。然后先从各块中抽取最大数据元素构成一个索引表，由于数据元素分块有序，所以索引表是有序的。接下来查找过程分两步进行：先在索引表中进行折半或顺序查找，以确定待查记录的“所在块”，然后在已限定的那一块中进行顺序查找。<br><img src="/images/search_al/blocksearch.png"><br>要注意的是，一般把下标为0的空间空出来。<br><strong>C++描述：</strong></p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">typedef struct&#123;</span><br><span class="line">    ElemType *<span class="built_in">elem</span>;</span><br><span class="line">    int <span class="built_in">length</span>;  //表中数据元素个数</span><br><span class="line">&#125; SSTable;</span><br><span class="line"></span><br><span class="line">typedef struct&#123;</span><br><span class="line">    KeyType <span class="built_in">key</span>;</span><br><span class="line">    int stadr;</span><br><span class="line">&#125; indexItem;</span><br><span class="line"></span><br><span class="line">typedef struct&#123;</span><br><span class="line">    indexItem *<span class="built_in">elem</span>;</span><br><span class="line">    int <span class="built_in">length</span>;</span><br><span class="line">&#125; indexTable;</span><br><span class="line"></span><br><span class="line">int Search_Idx(SSTable ST, indexTable ID, KeyType kval)&#123;</span><br><span class="line">    int low,high,mid,s,t,k;</span><br><span class="line">    bool found;</span><br><span class="line"></span><br><span class="line">    //在顺序表ST中分块查找等于给定值kval的数据元素，ID为索引表</span><br><span class="line">    //若找到，则返回该数据元素在ST中的位置，否则返回<span class="number">0</span></span><br><span class="line">    low=<span class="number">0</span>;</span><br><span class="line">    high=ID.<span class="built_in">length</span>-<span class="number">1</span>;</span><br><span class="line">    found=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(kval&gt;ID.<span class="built_in">elem</span>[high].<span class="built_in">key</span>)&#123; //当给定值kval比表中所有数据元素都大</span><br><span class="line">        <span class="built_in">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(low&lt;=high &amp;&amp; !found)&#123; //折半查找索引表，确定查找区间</span><br><span class="line">        mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(kval&lt;ID.<span class="built_in">elem</span>[mid].<span class="built_in">key</span>)&#123;</span><br><span class="line">            high=mid-<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(kval&gt;ID.<span class="built_in">elem</span>[mid].<span class="built_in">key</span>)&#123;</span><br><span class="line">            low=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            found=<span class="literal">true</span>;low=mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;//<span class="keyword">while</span></span><br><span class="line">    s=ID.<span class="built_in">elem</span>[low].stadr;  //经索引表查找后，下一步的查找范围定位在第low块</span><br><span class="line">    <span class="keyword">if</span>(low&lt;ID.<span class="built_in">length</span>-<span class="number">1</span>)&#123;</span><br><span class="line">        t=ID.<span class="built_in">elem</span>[low+<span class="number">1</span>].stadr-<span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        t=ST.<span class="built_in">length</span>;     //s和t为在ST表进行查找的下界和上界</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ST.<span class="built_in">elem</span>[t].<span class="built_in">key</span>==kval)&#123;</span><br><span class="line">        <span class="built_in">return</span> t;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;          //在ST.<span class="built_in">elem</span>[s]至ST.<span class="built_in">elem</span>[t-<span class="number">1</span>]的区间内进行顺序查找</span><br><span class="line">        ST.<span class="built_in">elem</span>[<span class="number">0</span>]=ST.<span class="built_in">elem</span>[t];   //ST.<span class="built_in">elem</span>[<span class="number">0</span>]用来暂存ST.<span class="built_in">elem</span>[t]</span><br><span class="line">        ST.<span class="built_in">elem</span>[t].<span class="built_in">key</span>=kval;        //设置哨兵</span><br><span class="line">        <span class="keyword">for</span>(k=s;ST.<span class="built_in">elem</span>[k].<span class="built_in">key</span>!=kval;k++);</span><br><span class="line">        ST.<span class="built_in">elem</span>[t]=ST.<span class="built_in">elem</span>[<span class="number">0</span>];   //回复暂存值</span><br><span class="line">        <span class="keyword">if</span>(k!=t)&#123;</span><br><span class="line">            <span class="built_in">return</span> k;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>平均查找长度：</strong> 由于分块查找实际上是进行了两次查找，则整个算法的平均查找长度是两次查找的平均查找长度之和。假设索引表的长度为b，顺序表的长度为n，则以二分查找确定块时整个分块查找的平均查找长度为：<br><strong>ASL(n)=ASL(b)+ASL(n/b)≈log(b+1)-1+(n/b+1)/2</strong>。<br><strong>注意：</strong> 一般情况下为进行索引顺序查找，不一定要将顺序表等分成若干块并提取每块的最大关键字作为索引项，有时也可根据顺序表中的关键字的特征来分块。</p>
<h3 id="4-插值查找"><a href="#4-插值查找" class="headerlink" title="4.插值查找"></a>4.插值查找</h3><p><strong>介绍：</strong> 在介绍插值查找之前，我们想想，为什么二分查找算法一定要是折半，而不是折四分之一或者折更多呢？打个比方，要在取值范围1 ~ 10000 之间 100 个元素从小到大均匀分布的数组中查找5，我们自然会考虑从数组下标较小的开始查找。也就是说，折半查找这种查找方式，不是自适应的。二分查找中查找点计算如下：<br><strong>mid=(low+high)/2, 即mid=low+1/2*(high-low)</strong><br><img src="/images/search_al/inbisearch.png"><br>通过类比，我们可以将查找的点改进为如下：<br><strong>mid=low+(key-a[low])/(a[high]-a[low])*(high-low)</strong><br><img src="/images/search_al/ininsearch.png"><br>也就是将上述的比例参数1/2改进为自适应的，根据关键字在整个有序表中所处的位置，让mid值的变化更靠近关键字key，这样也就间接地减少了比较次数。<br><strong>算法思想：</strong> 基于二分查找算法，将查找点的选择改进为自适应选择，可以提高查找效率。当然，插值查找也属于有序查找。<br><strong>C++描述：</strong></p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">typedef struct&#123;</span><br><span class="line">    ElemType *<span class="built_in">elem</span>;</span><br><span class="line">    int <span class="built_in">length</span>;  //表中数据元素个数</span><br><span class="line">&#125; SSTable;</span><br><span class="line"></span><br><span class="line">int InsertionSearch(SSTable ST, KeyType kval, int low, int high)</span><br><span class="line">&#123;</span><br><span class="line">    int mid = low+((kval-ST.<span class="built_in">elem</span>[low].<span class="built_in">key</span>)*(ST.<span class="built_in">elem</span>[high].<span class="built_in">key</span>-ST.<span class="built_in">elem</span>[low].<span class="built_in">key</span>)/(ST.<span class="built_in">elem</span>[high].<span class="built_in">key</span>-ST.<span class="built_in">elem</span>[low].<span class="built_in">key</span>));</span><br><span class="line">    <span class="keyword">if</span>(ST.<span class="built_in">elem</span>[mid].<span class="built_in">key</span> &gt; kval)&#123;</span><br><span class="line">        <span class="built_in">return</span> InsertionSearch(ST, kval, low, mid-<span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ST.<span class="built_in">elem</span>[mid].<span class="built_in">key</span> &lt; kval)&#123;</span><br><span class="line">        <span class="built_in">return</span> InsertionSearch(ST, kval, mid+<span class="number">1</span>, high);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度分析：</strong> 查找成功或者失败的时间复杂度均为<strong>O(log(logn))</strong>。<br><strong>注意：</strong> 对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好的多。反之，数组中如果分布非常不均匀，那么插值查找未必是很合适的选择。</p>
<h3 id="5-二叉树查找"><a href="#5-二叉树查找" class="headerlink" title="5.二叉树查找"></a>5.二叉树查找</h3><p><strong>二叉查找树介绍：</strong> 二叉查找树也叫二叉排序树，它或者是一棵空树，或者是具有下列性质的二叉树：<br>（1）若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；<br>（2）若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；<br>（3）任意节点的左、右子树也分别为二叉查找树。<br><strong>算法思想：</strong> 对待查找的数据元素生成二叉查找树，然后将给定值和根结点的关键字进行比较，若相等，则查找成功，否则依据给定值小于或大于根结点的关键字，继续在左子树和右子树中进行查找，直至查找成功或者因左子树或右子树为空树为止，后者说明查找不成功。这个算法的查找效率很高，但是如果使用这种查找方法要首先创建二叉查找树。<br><img src="/images/search_al/bisearchtree.gif"><br><strong>注意：</strong> 这里要注意与折半查找的二叉判定树区分，二叉判定树是用来分析某个算法而设计的二叉树，而二叉排序树是用来对一组关键字进行排序的方法。<br><strong>C++描述：</strong></p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">typedef struct BiTNode&#123;</span><br><span class="line">	ElemType <span class="keyword">data</span>;</span><br><span class="line">	struct BiTNode *lchild,*rchild;</span><br><span class="line">&#125; BiTNode,*BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建二叉查找树</span></span><br><span class="line">void Insert_BST(BiTree &amp;T,KeyType e)&#123;</span><br><span class="line">	BiTNode *s,*p,*f;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//在以T为根指针的二叉排序树中插入记录e</span></span><br><span class="line">	s=new BiTNode;</span><br><span class="line">	<span class="function"><span class="title">s</span>-&gt;</span><span class="keyword">data</span>.key=e;</span><br><span class="line">	<span class="function"><span class="title">s</span>-&gt;</span>lchild=NULL;</span><br><span class="line">	<span class="function"><span class="title">s</span>-&gt;</span>rchild=NULL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(!T)&#123;</span><br><span class="line">		T=s;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		p=T;</span><br><span class="line">		<span class="keyword">while</span>(p)&#123;</span><br><span class="line">			<span class="function"><span class="title">if</span>(e&lt;p-&gt;</span><span class="keyword">data</span>.key)&#123;</span><br><span class="line">				f=p;</span><br><span class="line">				<span class="function"><span class="title">p</span>=p-&gt;</span>lchild;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				f=p;</span><br><span class="line">				<span class="function"><span class="title">p</span>=p-&gt;</span>rchild;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="title">if</span>(e&lt;f-&gt;</span><span class="keyword">data</span>.key)&#123;</span><br><span class="line">			<span class="function"><span class="title">f</span>-&gt;</span>lchild=s;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="function"><span class="title">f</span>-&gt;</span>rchild=s;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找</span></span><br><span class="line">bool Search_BST(BiTree T, KeyType kval,BiTree &amp;p,BiTree &amp;f)&#123;</span><br><span class="line">	p=T;</span><br><span class="line">	<span class="keyword">while</span>(p)&#123;</span><br><span class="line">		<span class="function"><span class="title">if</span>(kval==p-&gt;</span><span class="keyword">data</span>.key)&#123;</span><br><span class="line">			return <span class="literal">true</span>;</span><br><span class="line">		&#125;<span class="function"><span class="title">else</span> <span class="keyword">if</span>(kval&lt;p-&gt;</span><span class="keyword">data</span>.key)&#123;</span><br><span class="line">			f=p;</span><br><span class="line">			<span class="function"><span class="title">p</span>=p-&gt;</span>lchild;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			f=p;</span><br><span class="line">			<span class="function"><span class="title">p</span>=p-&gt;</span>rchild;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-哈希查找"><a href="#6-哈希查找" class="headerlink" title="6.哈希查找"></a>6.哈希查找</h3><p><strong>介绍：</strong> 在上述的查找中，由于数据元素在线性表中的存储位置是随机的，和关键字无关，因此在查找时，需将给定值和线性表中记录的关键字逐个比较，查找的效率基于历经比较的关键字的个数。设想，若在数据元素的关键字和其存储位置（数组下标）之间建立一个确定的函数关系f，即将关键字为key的记录存储在下标为Hash(key)的位置上，这样在查找关键字等于给定值kval的记录时，仅需直接对给定值进行某种运算，求得记录的存储位置Hash(kval)，而不需要和其他记录的关键字进行比较。按这种方法组织数据，在进行查找时将会有效减少针对关键字的比较次数，也就可以从根本上降低平均查找长度ASL的值。而哈希查找就是通过计算数据元素的存储地址进行查找的一种方法。<br><strong>哈希函数：</strong> Hash(key)称为哈希函数。<br><strong>冲突：</strong> 对不同的关键字key1和key2得到相同的哈希地址（即哈希函数值）Hash(key1)=Hash(key2)的这种现象称为冲突。在设定哈希函数时要考虑不发生冲突，然而实际上不发生冲突的哈希函数极少存在，只能设定对给定的关键字集合冲突尽可能少的哈希函数，在产生冲突时进行再散列，即为那些哈希地址位置已被其他记录占用的记录安排另外的存储位置。因此在建哈希表的时候，不但要设定一个哈希函数，还要设定一个处理冲突的方法。<br><strong>哈希表：</strong> 哈希表是根据设定的哈希函数和处理冲突的方法为一组数据元素建立的一种存储结构。哈希函数又称散列函数，构造哈希表的方法又称散列技术。<br><strong>装填系数：</strong> 假设哈希表的空间大小为m，在表中填入的数据元素数为n，定义a=n/m为哈希表的装填系数，实际应用时，常取a为0.65~0.85.<br><strong>构造哈希函数的方法：</strong><br>（1）除留余数法：取关键字被某个不大于哈希表表长m的数p除后所得余数为哈希地址，即设定哈希函数为Hash(key)=key mod p (p&lt;=m)。通常取p为不大于表长且最接近表长m的素数。如当哈希表表长为1000，可取p=977。<br>（2）平方取中法：取关键字平方后的中间几位为哈希地址，因为一个数的平方值的中间几位和这个数的每一位都相关，则对不同的关键字得到的哈希函数值不易产生冲突。若哈希表表长为1000，则可取关键字平方值的中间3位。比如关键字为1234，那么1234²=1522756，可取227作为地址。<br>（3）折叠法：将关键字分割成位数相同的几部分（最后一部分位数可以不同），然后取这几部分的叠加和（舍去进位）作为哈希地址。当关键字的位数很多且每一位的值都随机出现时，采用这种方法可得到冲突较少的哈希地址。<br>a. 移位叠加：将分割后的每一部分的最低位对齐，然后相加。如key=123456789，H(key)=123+456+789=1368。<br>b. 间界叠加：从一端向另一端沿分割界来回折叠，然后对齐相加。如key=123456789，H(key)=123+654+789=1566。<br><strong>处理冲突的方法：</strong><br>（1）开放地址法<br>从哈希函数求得一个地址序列H[1],H[2],…,H[k]，即哈希表中下标为H[1]，H[2]，H[k-1]的存储空间都已有记录，直至下标H[k]为空（若哈希表不满，必能找到k&lt;=m-1）。即 H[i]=(Hash(key)+d[i]) mod m , Hash(key)为哈希函数，m为哈希表的表长，d[i]为增量序列。<br>增量序列的取法有下列三种：<br>a. d[i]=1,2,3,…,m-1,称为线性探测再散列。这种取法最简单，只要哈希表没填满就总能找到一个空的位置，但容易对之后填入的记录增加冲突。<br>b. d[i]=1², -1², 2², -2²,…,k²,-k²（k&lt;=m/2），称为二次探测再散列。这种取法要求表长m必须是形如4j+3(j=1,2,…)的素数，如7,11,19,23,…等。<br>c. d[i]是一个伪随机序列，称为随机探测再散列。用这种取法时需选择一个伪随机函数产生伪随机数列，且在建表装填和查找时应使用同一个伪随机函数来生成伪随机数列。<br>（2）链地址法<br>将所有key对应的Hash(key)相同的记录存储在同一线性链表中，而哈希表中下标为i的空间存储哈希函数值为i的链表头指针。<br><img src="/images/search_al/linkarr.jpeg"><br><strong>算法流程：</strong> 哈希表的查找过程和建表过程一致，以开放地址处理冲突线性探测再散列为例。假设哈希函数为Hash(x)，则查找过程为：对给定值kval，求得哈希地址为j=Hash(kval)，若哈希表中下标为j的空间为空，则查找不成功，可将关键字等于kval的记录填入；若表中该空间不空且所填记录的关键字等于kval，则查找成功，否则按建表时设定的散列方法重复计算处理冲突后的各个地址，直至表中相应空间为空或者所填记录的关键字等于kval，前者表示查找不成功，后者查找成功。<br><strong>C++描述：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NULLKEY=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	ElemType *elem;</span><br><span class="line">	<span class="keyword">int</span> count;</span><br><span class="line">&#125; HashTable;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Hash</span><span class="params">(<span class="keyword">int</span> kval)</span></span>&#123;   <span class="comment">//除留余数法</span></span><br><span class="line">	<span class="keyword">return</span> kval%NUM;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Next</span><span class="params">(<span class="keyword">int</span> &amp;p, <span class="keyword">int</span> &amp;c)</span></span>&#123;   <span class="comment">//线性探测再散列</span></span><br><span class="line">	p=(p+<span class="number">1</span>)%LENGTH;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">HashSearch</span><span class="params">(HashTable H, KeyType kval,<span class="keyword">int</span> &amp;p,<span class="keyword">int</span> &amp;c)</span></span>&#123;</span><br><span class="line">	<span class="comment">//在开放定址哈希表H中查找关键码为kval的元素，</span></span><br><span class="line">	<span class="comment">//若查找成功，以p指示待查记录在表中位置,并返回p；否则，以p指示插入位置，并返回-1；</span></span><br><span class="line">	<span class="comment">//以c计算冲突次数，其初值置0，供建表插入时参考</span></span><br><span class="line">	p=Hash(kval);   <span class="comment">//求得哈希地址</span></span><br><span class="line">	<span class="keyword">while</span> (H.elem[p].key != NULLKEY &amp;&amp; (H.elem[p].key != kval))&#123; <span class="comment">//位置中有记录且不等于kval，即有冲突</span></span><br><span class="line">		Next(p,++c);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(H.elem[p].key==kval)&#123;</span><br><span class="line">		<span class="keyword">return</span> p;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InsertHash</span><span class="params">(HashTable &amp;H,ElemType e)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> c=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(HashSearch(H,e.key,j,c)!=<span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		H.elem[j]=e;</span><br><span class="line">		++H.count;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>未完待续~</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、查找算法的相关概念&quot;&gt;&lt;a href=&quot;#一、查找算法的相关概念&quot; class=&quot;headerlink&quot; title=&quot;一、查找算法的相关概念&quot;&gt;&lt;/a&gt;一、查找算法的相关概念&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;关键字的定义：&lt;/strong&gt; 关键字是数据元素中
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Flask学习教程 Part1 4.2:表单处理</title>
    <link href="http://yoursite.com/2016/07/07/formhtml/"/>
    <id>http://yoursite.com/2016/07/07/formhtml/</id>
    <published>2016-07-07T08:05:55.000Z</published>
    <updated>2016-07-07T15:35:37.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="表单渲染"><a href="#表单渲染" class="headerlink" title="表单渲染"></a>表单渲染</h2><p>在上一节中，我们定义了一个Web表单了，那么现在我们就来将这个表单渲染成HTML，在模板中生成出来看看。</p>
<p>修改index.html如下：<br><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> page_content %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"page-header"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, </span><span class="template-tag">&#123;% <span class="name"><span class="name">if</span></span> name %&#125;</span><span class="xml"></span><span class="template-variable">&#123;&#123; name &#125;&#125;</span><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">else</span></span> %&#125;</span><span class="xml">Stranger</span><span class="template-tag">&#123;% <span class="name"><span class="name">endif</span></span> %&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">"POST"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    </span><span class="template-variable">&#123;&#123; form.hidden_tag() &#125;&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">    </span><span class="template-variable">&#123;&#123; form.name.label &#125;&#125;</span><span class="xml"> </span><span class="template-variable">&#123;&#123; form.name() &#125;&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">    </span><span class="template-variable">&#123;&#123; form.submit() &#125;&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure></p>
<p>1.首先修改了主页头部所显示的欢迎消息，当我们给name传入值时，就把这个值传入并返回出来，当我们没有给name传入值，就返回Hello，Stranger！<br>2.这里设置了一个参数form，NameForm表单类的实例将会通过这个参数传入模板，从而在模板中生成这个表单。<br>3.method=”POST”说明提交表单使用的是POST方法。<br>4.hidden_tag()是Form类中的一个方法，它在一个隐藏的DIV标签中渲染任何隐藏的字段（包括CSRF字段）。<br>5.form.name.label表示调用所传入的表单实例中name字段的第一个参数值字符串。如果我们传入了NameForm表单类的实例，这里就会显示”What is your name?”。<br>6.form.name()表示调用所传入的表单实例中的name字段。如果我们传入了NameForm表单类的实例，这里就会显示一个输入文本框。<br>7.form.submit()表示调用所传入的表单实例中的submit字段。如果我们传入了NameForm表单类的实例，这里就会显示一个提交按钮，用来提交表单。</p>
<p>这样子，就能把表单渲染出来了。但是要成功显示表单，还需要修改视图函数。</p>
<h2 id="在视图函数中处理表单"><a href="#在视图函数中处理表单" class="headerlink" title="在视图函数中处理表单"></a>在视图函数中处理表单</h2><p>视图函数index()不仅要渲染表单，还要接受表单中的数据。修改hello.py如下：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@app.route(<span class="string">'/'</span>, methods=[<span class="string">'GET'</span>, <span class="string">'POST'</span>])</span><br><span class="line">def <span class="built_in">index</span>():</span><br><span class="line">    <span class="keyword">name</span> = <span class="keyword">None</span></span><br><span class="line">    <span class="keyword">form</span> = NameForm()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">form</span>.validate_on_submit():</span><br><span class="line">        <span class="keyword">name</span> = <span class="keyword">form</span>.<span class="keyword">name</span>.<span class="keyword">data</span></span><br><span class="line">        <span class="keyword">form</span>.<span class="keyword">name</span>.<span class="keyword">data</span> = <span class="string">''</span></span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">'index.html'</span>, <span class="keyword">form</span>=<span class="keyword">form</span>, <span class="keyword">name</span>=<span class="keyword">name</span>)</span><br></pre></td></tr></table></figure>
<p>1.首先，在app.toute()中添加一个methods参数，并指定‘GET’和‘POST’。说明在URL映射中把这个视图函数注册为GET和POST请求的处理程序(即该路由可处理‘GET’和‘POST’请求)。如果methods参数没有指定，则默认把该视图函数注册为GET请求的处理程序。<br>2.接下来设置了一个局部变量name，用来存放在表单中输入的名字，当没有输入时，其默认值为None。<br>3.然后创建一个NameForm实例，它叫form，用来表示表单。<br>4.接下来的validate_on_submit()是NameForm表单类中的一个方法。提交表单后，如果输入表单的数据可被所有验证函数接受，那么validate_on_submit()方法就返回True，否则返回False。这决定了程序是处理表单提交的数据还是重新渲染表单。<br>5.在这里，如果用户是第一次访问该程序，服务器就会收到一个没有表单数据的GET请求，那么这时validate_on_submit()将返回False。if条件语句的内容将全部跳过，直接调用render_templat()渲染index.html模板，同时将NameForm的实例form作为值传入给index.html中的form参数，显示出表单，并将这里name参数的值None传入给index.html中的name参数。所以我们首次打开该网站就会看到浏览器显示了一个表单。<br>6.当用户提交表单，服务器就会收到一个包含着表单数据的POST请求。这时validate_on_submit()方法会调用表单form中的name字段上附属的Required()验证函数。如果没有在表单中输入数据，validate_on_submit()方法仍然返回False，从而重复上一步骤。如果表单数据不为空，validate_on_submit()方法就返回True。<br>7.当validate_on_submit()方法返回True，就执行接下来的if语句。StringField中有一个data属性，可用于获取输入表单中的数据。于是这里通过form中的name字段中的data属性获取用户输入表单中的名字，并将其赋值给局部变量name。<br>8.赋值完毕后，再将data属性的值设置为空字符串，从而清空表单的name字段。<br>9.最后，渲染模板，同时将NameForm的实例form作为值传入给index.html中的form参数，将name参数的值传入给index.html中的name参数。这一次name参数的值将不再是None，而是用户所输入的名字。</p>
<p>接下来我们来看看这个表单长什么样子吧。运行程序，访问<a href="http://127.0.0.1:5000/" target="_blank" rel="noopener">http://127.0.0.1:5000/</a> ：<br><img src="/images/form0.jpg"></p>
<p>这是用户首次访问网站是浏览器所显示的表单。当用户在表单中输入名字rose，并按Submit按钮提交表单，就可看到：<br><img src="/images/form1.jpg"><br>这时就显示了一个针对用户rose的欢迎消息。</p>
<p>而如果我们没有输入名字就直接按提交按钮，将会重新渲染表单。</p>
<p>Last：<br>Next：</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;表单渲染&quot;&gt;&lt;a href=&quot;#表单渲染&quot; class=&quot;headerlink&quot; title=&quot;表单渲染&quot;&gt;&lt;/a&gt;表单渲染&lt;/h2&gt;&lt;p&gt;在上一节中，我们定义了一个Web表单了，那么现在我们就来将这个表单渲染成HTML，在模板中生成出来看看。&lt;/p&gt;
&lt;p&gt;修改
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Flask学习教程 Part1 4.1:表单和表单类</title>
    <link href="http://yoursite.com/2016/06/20/form/"/>
    <id>http://yoursite.com/2016/06/20/form/</id>
    <published>2016-06-20T08:40:42.000Z</published>
    <updated>2017-04-08T05:43:31.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h2><p>表单的功能就是在网页中采集数据，其实表单就相当于我们平时用来提交资料、意见，规范流程执行过程的格式。一个表单有三个基本组成部分:</p>
<ul>
<li>表单标签(<code>&lt;form&gt;&lt;/form&gt;</code>):用于申明表单，定义采集数据的范围，将<code>&lt;form&gt;</code>和<code>&lt;/form&gt;</code>里面包含的数据将提交到服务器。</li>
<li>表单域:用于采集用户输入或选择的数据。包括有文本框、多行文本框、密码框、隐藏域、复选框、单选框和下拉选择框等。</li>
<li>表单按钮:用于将数据传送到服务器上的CGI脚本或者取消输入，还可以用表单按钮来控制其他定义了处理脚本的处理工作。有提交按钮、复位按钮和一般按钮。</li>
</ul>
<p>WTForms是一个Python表单验证、渲染开发包，其中有许多HTML标准字段和内建的验证函数。</p>
<ul>
<li><p>这些标准字段本质上是在wtforms中定义的类，有以下这些：</p>
<blockquote>
<p>StringField：文本字段<br>TextAreaField：多行文本字段<br>PasswordField：密码文本字段<br>HiddenField：隐藏文本字段<br>DateField：文本字段，值为datetime.date格式<br>DateTimeField：文本字段，值为datetime.datetime格式<br>IntegerField：文本字段，值为整型<br>DecimalField：文本字段，值为decimal.Decimal<br>FloatField：文本字段，值为浮点型<br>BooleanField：复选框，值为True或False<br>RadioField：一组单选框<br>SelectField：下拉列表<br>SelectMultipleField：下拉列表，可选择多个值<br>FileField：文件上传字段<br>SubmitField：表单提交按钮<br>FormField：把表单作为字段嵌入另外一个表单<br>FieldList：一组指定类型的字段</p>
</blockquote>
</li>
<li><p>而验证函数则是用来验证用户填写在表单中并提交的输入值是否符合要求的函数，有以下这些：</p>
<blockquote>
<p>Email：验证电子邮件地址<br>EqualTo：比较两个字段的值(常用于要求输入两次密码进行确认的情况)<br>IPAddress：验证IPv4网络地址<br>Length：验证输入字符串的长度<br>NumberRange：验证输入的值在数字范围内<br>Optional：无输入值时跳过其他的验证函数<br>Required：确保字段中有数据(确保用户输入不为空)<br>Regexp：使用正则表达式验证输入值<br>URL：验证URL<br>AnyOf：确保输入值在可选值列表<br>NoneOf：确保输入值不在可选值列表</p>
</blockquote>
</li>
</ul>
<p>flask里的一个扩展:Flask-WTF，提供了简单的WTForms 集成。那么我们来安装这个flask扩展flask-wtf:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(venv) $ pip <span class="keyword">install</span> flask-wtf</span><br></pre></td></tr></table></figure></p>
<h2 id="表单类"><a href="#表单类" class="headerlink" title="表单类"></a>表单类</h2><p>使用Flask-WTF时，每一个Web表单都是一个继承自Form的类。表单类定义了表单中的字段，每一个字段都是WTForms中的字段类的实例。那么我们来给我们的hello.py定义一个表单类试试，在hello.py插入以下代码：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">from</span> flask.ext.wtf <span class="keyword">import</span> Form</span><br><span class="line"><span class="title">from</span> wtforms <span class="keyword">import</span> StringField, SubmitField</span><br><span class="line"><span class="title">from</span> wtforms.validators <span class="keyword">import</span> Required</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">NameForm</span>(<span class="type">Form</span>):</span></span><br><span class="line"><span class="class">    name = <span class="type">StringField</span>('<span class="type">What</span> <span class="title">is</span> <span class="title">your</span> <span class="title">name</span>?', <span class="title">validators</span>=[<span class="type">Required</span>()])</span></span><br><span class="line"><span class="class">    submit = <span class="type">SubmitField</span>('<span class="type">Submit</span>')</span></span><br></pre></td></tr></table></figure></p>
<p>1.首先,从flask.ext.wtf里导入Form类<br>2.从wtforms导入StringField、SubmitField类<br>3.从wtforms。validators导入Required验证函数<br>4.定义NameForm类，这个类继承自Form类<br>5.NameForm表单类中定义了一个叫name的文本字段，这个name是StringField类的实例。StringField类的构造函数中的可选参数validators指定了一个列表，这个列表由验证函数组成，在接受用户提交的数据之前验证数据。这里这个列表中有Required()验证函数，确保用户提交的字段不为空。<br>6.NameForm中还定义了一个叫submit的表单提交按钮，这个submit是SubmitField类的实例。SubmitField类的构造函数的第一个参数就是把表单渲染成HTML时所使用的标号，这里为‘Submit’。</p>
<p>这样就定义了一个表单类了,这个表单的作用就是填写用户的名字并提交。</p>
<h2 id="CSRF保护"><a href="#CSRF保护" class="headerlink" title="CSRF保护"></a>CSRF保护</h2><p>这里还要注意一点，在使用WTF的时候，我们还必须要先设置一下app实例里的SECRET_KEY，否则就会引发错误。而这个设置是为了实现CSRF保护。</p>
<p>CSRF保护就是跨站请求伪造保护。默认情况下，Flask-WTF能够保护表单免受<a href="http://baike.baidu.com/link?url=IbwTLzpX997YmK2HIJoVodQDJea9bI8FoytXpW0ixcKW7EB2uwJNQjOtWJ_DjRDA7Ir12GoQ8OoEjcmr9JPuhK" target="_blank" rel="noopener">CSRF</a>的攻击。</p>
<p>那么我们来给我们的程序设置一个密钥，Flask-WTF会使用这个密钥生成加密令牌，再用加密令牌验证请求中的表单数据的真伪。修改hello.py如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app = Flask(__name__)</span><br><span class="line">app<span class="selector-class">.config</span>[<span class="string">'SECRET_KEY'</span>] = <span class="string">'hard to guess string'</span></span><br></pre></td></tr></table></figure></p>
<p>config是实例app中的一个字典(字典是python的一种数据结构类型，由键和对应的值成对组成)，用来储存了框架、扩展和程序本身的配置变量。这里把config中SECRET_KEY键的值设置为hard to guess string。SECRET_KEY这个配置变量就是通用密钥。</p>
<p>事实上，除了这样直接设置SECRET_KEY的值，我们还可以将密钥保存在文件或环境变量中，然后从文件或环境中导入其配置值。</p>
<p>Last:<br>Next:</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;表单&quot;&gt;&lt;a href=&quot;#表单&quot; class=&quot;headerlink&quot; title=&quot;表单&quot;&gt;&lt;/a&gt;表单&lt;/h2&gt;&lt;p&gt;表单的功能就是在网页中采集数据，其实表单就相当于我们平时用来提交资料、意见，规范流程执行过程的格式。一个表单有三个基本组成部分:&lt;/p&gt;
&lt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Flask学习教程 Part1 3.5:静态文件的引用</title>
    <link href="http://yoursite.com/2016/05/21/static/"/>
    <id>http://yoursite.com/2016/05/21/static/</id>
    <published>2016-05-21T01:33:45.000Z</published>
    <updated>2016-05-21T03:44:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>在一个应用程序中，不只是由代码和模块组成，还有一些静态的文件。所以这节就来讲一讲静态文件的引用。</p>
<p>要引用静态文件，就要给它生成一个URl地址，那么这里就要用到一个url_for()函数。所以先来讲一下这个函数的使用方法。</p>
<p>url_for()可以使用程序URL映射中保存的信息生成URL。它最简单的用法就是以视图函数名作为参数，返回对应的URL。</p>
<p>假如我们有一下这个路由：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@app.route(<span class="string">'/'</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span></span><span class="symbol">:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;h1&gt;Hello World!&lt;/h1&gt;'</span></span><br></pre></td></tr></table></figure></p>
<p>如果我们调用url_for(‘index’)，那么得到的结果将会是‘/’。而调用url_for(‘index’, _external=True)则返回绝对地址，即<a href="http://localhost:5000/" target="_blank" rel="noopener">http://localhost:5000/</a> 。</p>
<p>接下来我们来试一下给我们的程序加一个小图标。修改templates/base.html，在title块下面加入：<br><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> head %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"></span><span class="template-variable">&#123;&#123; super() &#125;&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"icon"</span> <span class="attr">href</span>=<span class="string">"</span></span></span><span class="template-variable">&#123;&#123; url_for('static', filename='icon.jpg') &#125;&#125;</span><span class="xml"><span class="tag"><span class="string">"</span></span></span></span><br><span class="line"><span class="xml">    type="image/x-icon"&gt;</span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure></p>
<p>1.这里我们给模板添加一个head块，作用是在HTML页面的头部添加一个图标。<br>2.用super()获取它的基模板(即bootstrap/base.html)里原本的内容。<br>3.接着就是添加图标。注意这里url_for()函数有两个参数，第一个参数’static’是Flask里的一个特殊的路由(之前在第二章查看URL映射的时候有看到它哦)，它映射到’/static/<filename>‘这个URL上。然后url_for()就给这个映射生成了URL。第二个参数就是文件名，给’/static/<filename>‘里的filename参数传入值。这里我的图标文件名为’icon.jpg’，所以这里url_for()函数返回的地址就是’/static/icon.jpg’。你也可以自己随便改，或者用你自己喜欢的图片。</filename></filename></p>
<p>注意，Flask默认在程序根目录下的static子目录寻找静态文件。所以这里我们要在程序根目录下创建一个static文件夹，把静态文件都放在里面。</p>
<p>这些都做好了，现在来看看这个图标，运行程序，可以看到：<br><img src="/images/icon.jpg"><br>看到那个图标了吧！！</p>
<p>Last：<br>Next：</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在一个应用程序中，不只是由代码和模块组成，还有一些静态的文件。所以这节就来讲一讲静态文件的引用。&lt;/p&gt;
&lt;p&gt;要引用静态文件，就要给它生成一个URl地址，那么这里就要用到一个url_for()函数。所以先来讲一下这个函数的使用方法。&lt;/p&gt;
&lt;p&gt;url_for()可以使
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Flask学习教程 Part1 3.4:使用Flask-Bootstrap集成Bootstrap</title>
    <link href="http://yoursite.com/2016/05/17/bootstrap/"/>
    <id>http://yoursite.com/2016/05/17/bootstrap/</id>
    <published>2016-05-17T14:28:01.000Z</published>
    <updated>2016-12-02T04:28:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>现在不管是哪一个页面都很丑，于是上一节我们说好了本节要把它写得好看点。这里又要用到一个FLask扩展，Flask－Bootstrap。</p>
<p>首先我们要知道一下Bootstrap，它是一个由Twitter开发的开源前端框架，基于HTML、CSS、JAVASCRIPT。</p>
<p>以下是《Flask Web 开发》里对它的一段介绍：</p>
<blockquote>
<p>Bootstrap是客户端框架，因此不会直接涉及服务器。服务器需要做的只是提供引用了Bootstrap层叠样式表(CSS)和JavaScript文件的HTML响应，并在HTML、CSS和Javascript代码中实例化所需组件。这些操作最理想的执行场所就是模板。</p>
</blockquote>
<p>在我们的程序中集成Bootstrap的一个简单的方法就是使用上面提到的Flask-Bootstrap扩展。现在我们来安装它：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(venv) $ pip <span class="keyword">install</span> flask-bootstrap</span><br></pre></td></tr></table></figure></p>
<p>然后再将它添加到我们的程序中，打开hello.py：<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from flask.<span class="keyword">ext.bootstrap </span>import <span class="keyword">Bootstrap</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">#...</span></span><br><span class="line"><span class="keyword">bootstrap </span>= <span class="keyword">Bootstrap(app)</span></span><br><span class="line"><span class="keyword">#...</span></span><br></pre></td></tr></table></figure></p>
<p>1.Flask-Bootstrap和前面的Flask-Script一样，也是包含在flask.ext命名空间中。这里从flask.ext.bootstrap导入Bootstrap类。<br>2.创造Bootstrap类的实例bootstrap，把程序实例app作为参数传入其构造函数。<br>3.记住Bootstrap的实例化要在Flask类的实例化后面。</p>
<p>这样初始化Flask-Bootstrap后，我们就可以在程序中使用一个包含了所有Bootstrap文件的基模板，这个模板具有页面的基本布局。我们的程序的基模板将会继承自这个基模板，然后让它具有更完整的页面布局，其中包括导航条，而页面内容则可以在其衍生模板中定义。</p>
<p>现在打开我们的base.html，修改如下：<br><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">% extends "bootstrap/base.html" %&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> title %&#125;</span><span class="xml">Play With Flask</span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> navbar %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"navbar navbar-inverse"</span> <span class="attr">role</span>=<span class="string">"navigation"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"navbar-header"</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">class</span>=<span class="string">"navbar-toggle"</span></span></span></span><br><span class="line"><span class="xml">             data-toggle="collapse" data-target=".navbar-collapse"&gt;</span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"sr-only"</span>&gt;</span>Toggle navigation<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"icon-bar"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"icon-bar"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"icon-bar"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"navbar-brand"</span> <span class="attr">href</span>=<span class="string">"/"</span>&gt;</span>Play With Flask<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"navbar-collapse collapse"</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"nav navbar-nav"</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/"</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> content %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    </span><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> page_content %&#125;</span><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure></p>
<p>1.extends指令从Flask-Bootstrap中导入bootstrap/base.html，表示我们这个基模板是继承自bootstrap中的基模板的。而Flask-Bootstrap中的这个基模板提供了一个网页框架，引入了Bootstrap中的所有CSS和JavaScript文件。<br>2.在我们的这个基模板中，block和endblock指令定义的块中的内容可以在其衍生模板中重新定义，添加到基模板中。<br>3.这个基模板定义了3个块：title、navbar和content，这些块事实上是bootstrap/base.html提供的，我们在这里重新定义。<br>4.title块的作用就是给渲染后的HTML文档头部添加内容，这些内容放在title标签中。<br>5.navbar块使用了Bootstrap组件给页面定义了一个简单的导航条。导航条中有Play With<br>Flask和Home选项。<br>6.content块表示页面的主体内容。在这个块中有一个div容器，其中包含一个名为page_content的新的空块，块中的内容由其衍生模板定义，内容将是页面的头部。</p>
<p>在一个程序中，一般所有的页面都应该有着相同的页面布局，所以如果我们现在要修改别的模块的话，就要复制粘贴上面的代码，再在相应的块中修改了。不过上一节我们说过了模板继承，避免了这种情况发生，现在你能体会到模板继承的用处了。</p>
<p>现在我们来修改index.html：<br><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">extends</span></span> "base.html" %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> title %&#125;</span><span class="xml"> - Index - </span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> page_content %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"page-header"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, World!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure></p>
<p>1.这个模板继承自我们的程序的基模板base.html，而不是Bootstrap的基模板bootstrap/base.html。<br>2.title块内容改为了Index，这将作为HTML文档头部。<br>3.在page_content块中插入了内容。</p>
<p>然后修改user.html：<br><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">extends</span></span> "base.html" %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> title %&#125;</span><span class="xml"> - User - </span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> page_content %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"page-header"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    </span><span class="template-tag">&#123;% <span class="name"><span class="name">if</span></span> name %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, </span><span class="template-variable">&#123;&#123; name &#125;&#125;</span><span class="xml">!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>   </span></span><br><span class="line"><span class="xml">    </span><span class="template-tag">&#123;% <span class="name"><span class="name">else</span></span> %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, Stranger!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">    </span><span class="template-tag">&#123;% <span class="name"><span class="name">endif</span></span> %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure></p>
<p>404.html：<br><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">extends</span></span> "base.html" %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> title %&#125;</span><span class="xml"> - 404 - </span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> page_content %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"page-header"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>404 Page Not Found<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure></p>
<p>500.html：<br><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">extends</span></span> "base.html" %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> title %&#125;</span><span class="xml"> - 500 - </span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> page_content %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"page-header"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>500 Internal Server Error<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure></p>
<p>然后我们来访问主页<a href="http://127.0.0.1:5000" target="_blank" rel="noopener">http://127.0.0.1:5000</a> ：<br><img src="/images/index2.jpg"></p>
<p>你可以自己试试访问其它页面～</p>
<p>是不是好看了那么一点点？</p>
<p>Last：<a href="http://roseou.github.io/2016/05/17/base/" target="_blank" rel="noopener">Flask学习教程 Part1 3.3:(强大的)模板继承</a><br>Next：<a href="http://roseou.github.io/2016/05/21/static/" target="_blank" rel="noopener">Flask学习教程 Part1 3.5:静态文件的引用</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在不管是哪一个页面都很丑，于是上一节我们说好了本节要把它写得好看点。这里又要用到一个FLask扩展，Flask－Bootstrap。&lt;/p&gt;
&lt;p&gt;首先我们要知道一下Bootstrap，它是一个由Twitter开发的开源前端框架，基于HTML、CSS、JAVASCRIPT
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Flask学习教程 Part1 3.3:(强大的)模板继承</title>
    <link href="http://yoursite.com/2016/05/17/base/"/>
    <id>http://yoursite.com/2016/05/17/base/</id>
    <published>2016-05-17T14:15:35.000Z</published>
    <updated>2016-05-21T03:48:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>或许你已经看到我的题目知道这一节要讲的是模板继承。模板继承是一种重复使用代码的方法。但是现在我们的模板都太过简单，完全没有重复的地方，然而实际上，一个应用中的不同页面往往长的差不多。现在我们来修改一下我们已有的模板，让它们看起来稍微有点像是来自于一个应用程序的。</p>
<p>index.html：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span> - Play With Flask - <span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>user.html：<br><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">title</span>&gt;</span> - Play With Flask - <span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml">    </span><span class="template-tag">&#123;% <span class="name"><span class="name">if</span></span> name %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, </span><span class="template-variable">&#123;&#123; name &#125;&#125;</span><span class="xml">!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">    </span><span class="template-tag">&#123;% <span class="name"><span class="name">else</span></span> %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, Stranger!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">    </span><span class="template-tag">&#123;% <span class="name"><span class="name">endif</span></span> %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>404.html：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span> - Play With Flask - <span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>404 Page Not Found<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>500.html：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span> - Play With Flask - <span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>500 Internal Server Error<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>然后我们来看看它们现在是什么样，运行程序。</p>
<p>访问 <a href="http://127.0.0.1:5000/" target="_blank" rel="noopener">http://127.0.0.1:5000/</a><br><img src="/images/index0.jpg"></p>
<p>可以看到上面多出了一个标题’- Play With Flask-‘，依次访问其它几个URL也可以看到这个标题，其他的内容都和之前的一样。</p>
<p>嗯，现在它们终于有一点出自一个程序的样子了。并且明显能看到这些页面有很多代码都重复了（好吧也不是很多），总之如果每一个页面都要写很多重复的代码就会很麻烦。现在我们来用模板继承来简化它。</p>
<p>简单来说，就是把那些重复的代码写到一个基模板里，它的衍生模板在这个基模板的代码的基础上，加上自己的代码。</p>
<p>现在我们就来把这些重复代码写到基模板里。在templates文件夹中创建一个base.html文件，写入下面的代码：<br><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml">    </span><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> head %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">title</span>&gt;</span></span><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> title %&#125;</span><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span><span class="xml"> - Play With Flask - <span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="xml">    </span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml">    </span><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> body %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">    </span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>1.这个就是我们的基模板啦，之后我们所有的其它模板都将继承于它，称为这个基模板的衍生模板。<br>2.可以看到模板加入了一个block标签。block标签所定义的元素可以在衍生模板中修改。例如这里，head和body元素都可在衍生模板中修改。<br>3.在这个模板中，我们定义了三个块，head、title和body。注意，title块包含在head块中。</p>
<p>然后我们来修改这个基模板的衍生模板。先是index.html:<br><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">extends</span></span> "base.html" %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> title %&#125;</span><span class="xml">Index</span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> head %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">    </span><span class="template-variable">&#123;&#123; super() &#125;&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> body %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure></p>
<p>user.html:<br><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> title %&#125;</span><span class="xml">User</span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> head %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">    </span><span class="template-variable">&#123;&#123; super() &#125;&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">block</span></span> body %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">    </span><span class="template-tag">&#123;% <span class="name"><span class="name">if</span></span> name %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, </span><span class="template-variable">&#123;&#123; name &#125;&#125;</span><span class="xml">!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">    </span><span class="template-tag">&#123;% <span class="name"><span class="name">else</span></span> %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, Stranger!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">    </span><span class="template-tag">&#123;% <span class="name"><span class="name">endif</span></span> %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">endblock</span></span> %&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure></p>
<p>1.衍生模板中有一个extends指令，这个指令声明了这个模板衍生自base.html。<br>2.基模板中的三个块head、title和body被重新定义，模板引擎Jinja2会将其插入相应的位置。<br>3.在这两个衍生模板中，都新定义了title块，一个插入了‘index’，一个插入了‘User’。<br>4.在这里，新定义的head块实际上没有改变基模板里的内容，而是使用super()来获取了基模板原来的内容（‘— Play With Flask —’）。<br>5.然后在body块中，index.html和user.html都重新插入了不同的内容。</p>
<p>现在，运行hello.py，访问 <a href="http://127.0.0.1:5000/" target="_blank" rel="noopener">http://127.0.0.1:5000/</a> ：<br><img src="/images/index1.jpg"><br> 可以看到标题里多出了head块里的‘index’。</p>
<p> 访问 <a href="http://127.0.0.1:5000/user/rose" target="_blank" rel="noopener">http://127.0.0.1:5000/user/rose</a> ：<br> <img src="/images/user1.jpg"><br> 标题里多出了head块里的‘User’。</p>
<p> 404.html和500.html的改法也是一样的，这里就不重复再说了，你们可以自己当练习试一下。</p>
<p> 实际上，这一节中使用模板继承并没有省下多少代码，因为我们的页面太简单，也太丑..不过，这里我也只想你们理解模板继承的原理就够了。下一节我们会为我们的页面添加别的东西，也会因此见识到模板继承的用处有多大。</p>
<p> Last：<a href="http://roseou.github.io/2016/05/17/wrongpage/" target="_blank" rel="noopener">Flask学习教程 Part1 3.2:错误页面</a><br> Next：<a href="http://roseou.github.io/2016/05/17/bootstrap/" target="_blank" rel="noopener">Flask学习教程 Part1 3.4:使用Flask-Bootstrap集成Bootstrap</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;或许你已经看到我的题目知道这一节要讲的是模板继承。模板继承是一种重复使用代码的方法。但是现在我们的模板都太过简单，完全没有重复的地方，然而实际上，一个应用中的不同页面往往长的差不多。现在我们来修改一下我们已有的模板，让它们看起来稍微有点像是来自于一个应用程序的。&lt;/p&gt;
&lt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Flask学习教程 Part1 3.2:错误页面</title>
    <link href="http://yoursite.com/2016/05/17/wrongpage/"/>
    <id>http://yoursite.com/2016/05/17/wrongpage/</id>
    <published>2016-05-17T13:02:38.000Z</published>
    <updated>2016-05-17T14:25:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>当请求错误时，我们需要有一个页面来显示一些错误信息告诉我们发生了什么错误。Flask中还有一个abort()函数用来处理错误，返回一个显示相应错误消息的页面。以下是一个例子：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@app.route(<span class="string">'/'</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span></span><span class="symbol">:</span></span><br><span class="line">    abort(<span class="number">400</span>)</span><br></pre></td></tr></table></figure></p>
<p>当我们访问<a href="http://127.0.0.1:5000/" target="_blank" rel="noopener">http://127.0.0.1:5000/</a> 时，就会自动返回一个显示400错误消息的页面，这个页面是这样的：<br><img src="/images/badrequest.jpg"><br>它告诉了我们浏览器发送了一个服务器无法理解的请求。</p>
<p>可是这个页面有点丑，我们可以<strong>自定义错误页面</strong>。这也是这一小节想说的，前面的都是铺垫啊铺垫。</p>
<p>首先，我们来添加两个处理错误的路由，打开hello.py，加入代码如下：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#...</span></span><br><span class="line"></span><br><span class="line">@app.errorhandler(<span class="number">404</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">page_not_found</span><span class="params">(e)</span></span><span class="symbol">:</span></span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">'404.html'</span>), <span class="number">404</span></span><br><span class="line"></span><br><span class="line">@app.errorhandler(<span class="number">500</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">internal_server_error</span><span class="params">(e)</span></span><span class="symbol">:</span></span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">'500.html'</span>), <span class="number">500</span></span><br><span class="line"><span class="comment">#...</span></span><br></pre></td></tr></table></figure></p>
<p>1.这两个路由都用到了实例app里的errorhandler()装饰器，这个函数接受数字状态码作参数，来处理相应的错误。<br>2.第一个路由用来处理404错误，当客户端请求未知页面或路由时显示。<br>3.第二个路由用来处理500错误，当有未处理的异常时显示。</p>
<p>那么，现在我们来自己编写这两个错误页面吧。<br>进入templates文件夹，创建404.html，输入如下代码：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>404 Page Not Found<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>再创建500.html，输入如下代码：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>500 Internal Server Error<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>现在我们来试一试看看。运行程序，请求一个不存在的URl，例如输入<a href="http://127.0.0.1:5000/hello" target="_blank" rel="noopener">http://127.0.0.1:5000/hello</a> , 就会看到：<br><img src="/images/404.jpg"><br>我们自定义的错误页面显示出来了！！</p>
<p>可是这个错误页面也还是丑，没关系，之后会写得好看一点的～</p>
<p>Last: <a href="http://roseou.github.io/2016/05/16/templates/" target="_blank" rel="noopener">Flask学习教程 Part1 3.1:用Jinja2渲染模板</a><br>Next: <a href="http://roseou.github.io/2016/05/17/base/" target="_blank" rel="noopener">Flask学习教程 Part1 3.3:(强大的)模板继承</a>  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当请求错误时，我们需要有一个页面来显示一些错误信息告诉我们发生了什么错误。Flask中还有一个abort()函数用来处理错误，返回一个显示相应错误消息的页面。以下是一个例子：&lt;br&gt;&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td 
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Flask学习教程 Part1 3.1:用Jinja2渲染模板</title>
    <link href="http://yoursite.com/2016/05/16/templates/"/>
    <id>http://yoursite.com/2016/05/16/templates/</id>
    <published>2016-05-16T13:30:34.000Z</published>
    <updated>2016-05-17T14:22:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>在上一章中，我们把生成的页面的HTML代码直接写到了视图函数的return语句里，事实上,我们不可能把所有HTML代码都写到里面。我们应该把代码写到一个模版里。</p>
<p>模板是一个包含响应文本的文件，其中包含用占位变量表示的动态部分，其具体值只在请求的上下文中（上下文的含义后面会提到，现在无需纠结）才能知道。使用真实值替换变量，再返回最终得到的响应字符串，这一过程称为渲染。Flask使用了Jinja2这个模板引擎来渲染模板。</p>
<p>好，那么我们现在把之前那两个路由的HTML代码放到模板里。首先我们要在playwithflask文件夹里创建一个叫templates文件夹，因为默认情况下Flask会在templates文件夹里寻找模板。然后进入templates文件夹，创建index.html文件来放显示程序根地址页面的代码：</p>
<p>playwithflask/templates/index.html:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>然后再创建一个user.html 。<br>playwithflask/templates/user.html:<br><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, </span><span class="template-variable">&#123;&#123; name &#125;&#125;</span><span class="xml">!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>接着再打开hello.py将代码修改如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, render_template</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">'index.html'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/user/&lt;name&gt;')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">user</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">'user.html'</span>, name=name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run(debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></p>
<p>现在来解释一下修改了的部分：<br>1.新导入了render_template()函数来渲染模板。</p>
<p>2.这个函数的第一个参数是模板的文件名，随后的参数都是键值对，表示模板中变量对应的真实值。</p>
<p>3.看到第二个路由里的user.html模板收到一个name变量。这里的name=name是关键字参数，左边是参数名，右边是传入该参数的值。</p>
<p>4.注意：上面说到Flask会在templates文件夹里寻找模板。事实上，如果你的应用是个模块，这个文件夹应该与模块同级；如果它是一个包，那么这个文件夹作为包的子目录。现在我们的应用只是一个单一的hello.py 模块，所以我们创建的templates文件夹与它同级。</p>
<p>嗯，修改好代码后，我们再来运行hello.py看看:<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(venv) $ <span class="keyword">python</span> hello.<span class="keyword">py</span></span><br><span class="line"> * Running <span class="keyword">on</span> http://<span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">5000</span>/ (Press CTRL+C <span class="keyword">to</span> <span class="keyword">quit</span>)</span><br><span class="line"> * Restarting with stat</span><br><span class="line"> * Debugger <span class="keyword">is</span> active!</span><br><span class="line"> * Debugger pin code: <span class="number">959</span>-<span class="number">578</span>-<span class="number">864</span></span><br></pre></td></tr></table></figure></p>
<p>现在打开浏览器，在地址栏输入<a href="http://127.0.0.1:5000/" target="_blank" rel="noopener">http://127.0.0.1:5000/</a> ，然后我们就会看到：<br><img src="/images/world.jpg"></p>
<p>如果输入<a href="http://127.0.0.1:5000/user/rose/" target="_blank" rel="noopener">http://127.0.0.1:5000/user/rose/</a> ，就会看到：<br><img src="/images/user.jpg"></p>
<p>效果跟之前是一摸一样的。</p>
<p>在这两个路由中，我们都是把一个URL和一个视图函数绑定，实际上，还可以把几个URL绑定到同一个函数上。再次打开hello.py把部分修改成：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#...</span></span><br><span class="line"></span><br><span class="line">@app.route(<span class="string">'/user/'</span>)</span><br><span class="line">@app.route(<span class="string">'/user/&lt;name&gt;'</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">user</span><span class="params">(name=None)</span></span><span class="symbol">:</span></span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">'user.html'</span>, name=name)</span><br><span class="line"></span><br><span class="line"><span class="comment">#...</span></span><br></pre></td></tr></table></figure></p>
<p>这里就把两个URL（’/user/‘和’/user/<name>‘）绑定到一个视图函数上啦，也就是请求这两个URL时，视图函数user()都会被调用。所以这里要给name参数一个默认值None，否则，当我们没有给name传入值时也就是访问’/user/‘这个URL时，就会报错。</name></p>
<p>然后再把playwithflask/templates/user.html修改成：<br><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">if</span></span> name %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, </span><span class="template-variable">&#123;&#123; name &#125;&#125;</span><span class="xml">!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">else</span></span> %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, Stranger!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">endif</span></span> %&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure></p>
<p>这里是Jinja2的语法。意思是当我们给name传入值时，就把这个值传入并返回出来，当我们没有给name传入值，就返回Hello，Stranger！</p>
<p>好，我们来启动服务器，并在浏览器中输入<a href="http://127.0.0.1:5000/user/" target="_blank" rel="noopener">http://127.0.0.1:5000/user/</a> 。<br><img src="/images/stranger.jpg"></p>
<p>然后如果给name输入值rose：<br><img src="/images/user.jpg"></p>
<p>嗯，模板就是这样渲染的。</p>
<p>Last: <a href="http://roseou.github.io/2016/05/15/script/" target="_blank" rel="noopener">Flask学习教程 Part1 2.3:使用Flask-Script扩展支持命令行选项</a><br>Next: <a href="http://roseou.github.io/2016/05/17/wrongpage/" target="_blank" rel="noopener">Flask学习教程 Part1 3.2:错误页面</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在上一章中，我们把生成的页面的HTML代码直接写到了视图函数的return语句里，事实上,我们不可能把所有HTML代码都写到里面。我们应该把代码写到一个模版里。&lt;/p&gt;
&lt;p&gt;模板是一个包含响应文本的文件，其中包含用占位变量表示的动态部分，其具体值只在请求的上下文中（上下文
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Flask学习教程 Part1 2.3:使用Flask-Script扩展支持命令行选项</title>
    <link href="http://yoursite.com/2016/05/15/script/"/>
    <id>http://yoursite.com/2016/05/15/script/</id>
    <published>2016-05-15T14:54:25.000Z</published>
    <updated>2016-12-01T14:01:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>在第一章关于Flask简介中就有提到过Flask很多高级功能都要通过扩展实现，这一节就来介绍一个Flask扩展，Flask-Script。这个扩展为Flask程序添加了一个命令行解析器，并自带了一组常用选项，它还支持自定义命令。</p>
<p>Flask的开发服务器支持很多启动设置选项，但只能在脚本中作为参数传给app.run()函数，例如域名和端口。这些每次当你想修改这些参数时，都要在代码中修改，十分麻烦。我们可以使用命令行参数传递设置选项，即在运行服务器前在命令行中传入参数。这个时候，我们就要用到Flask-Script。</p>
<p>首先来安装它：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(venv) $ pip install flask-<span class="keyword">script</span></span><br></pre></td></tr></table></figure></p>
<p>现在我们要把这个命令行解析功能添加到我们的程序中，打开hello.py，修改如下：<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask_script <span class="keyword">import</span> Manager</span><br><span class="line"></span><br><span class="line">manager = Manager(app)</span><br><span class="line"></span><br><span class="line">#...</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    manager.run()</span><br></pre></td></tr></table></figure></p>
<p>1.Flask-Script有一个Manager类,首先我们就从flask_script里导入Manager类。<br>2.然后创造一个Manager类的实例，它叫manager，并把程序实例app作为参数传给Manager类的构造函数。注意manager的实例化一定要在app的实例化之后。<br>3.最后用Manager里的run()函数启动服务器，然后就能解析命令行了。<br>4.注意，这里创建的manager对象可以在其它各个扩展中使用。</p>
<p>现在我们可以使用一些基本的命令行选项了。我们来运行一下hello.py，它会显出出关于命令行选项用法的消息：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(venv) $ <span class="keyword">python</span> hello.<span class="keyword">py</span></span><br><span class="line">usage: hello.<span class="keyword">py</span> [-?] &#123;<span class="keyword">shell</span>,runserver&#125; ...</span><br><span class="line"></span><br><span class="line">positional <span class="keyword">argument</span><span class="variable">s:</span></span><br><span class="line">  &#123;<span class="keyword">shell</span>,runserver&#125;</span><br><span class="line">    <span class="keyword">shell</span>            Runs <span class="keyword">a</span> Python <span class="keyword">shell</span> inside Flask application context.</span><br><span class="line">    runserver        Runs the Flask development server i.<span class="keyword">e</span>. app.run()</span><br><span class="line"></span><br><span class="line">optional <span class="keyword">argument</span><span class="variable">s:</span></span><br><span class="line">  -?, --<span class="keyword">help</span>         show this <span class="keyword">help</span> message <span class="built_in">and</span> <span class="keyword">exit</span></span><br></pre></td></tr></table></figure></p>
<p>1.首先它告诉我们它的用法就是在python hello.py后面直接加命令。如 python hello.py shell。<br>2.我们有两个可以用的命令行选项。shell和runserver。shell的作用就是在Flask应用上下文中运行Python shell，runserver就是运行Flask开发服务器：app.run()。<br>3.如果我们输入–help命令就会显示出帮助菜单。</p>
<p>我们可以试试用shell命令在程序的上下文中启动Python shell会话，我们可以使用这个会话进行维护、测试和调试异常。<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(venv) $ python hello.py shell</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>然后再来说说runserver这个用来启动服务器的命令。当我们运行python hello.py runserver 时，将会以调试模式启动Web服务器。基于runserver这个命令选项，我们还有很多选项可用：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">(venv) $ python hello.py runserver <span class="comment">--help</span></span><br><span class="line">usage: hello.py runserver [-?] [-h HOST] [-p PORT] [<span class="comment">--threaded]</span></span><br><span class="line">                          [<span class="comment">--processes PROCESSES] [--passthrough-errors] [-d]</span></span><br><span class="line">                          [-D] [-r] [-R]</span><br><span class="line"></span><br><span class="line">Runs the Flask development server i.e. app.run()</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">  -?, <span class="comment">--help            show this help message and exit</span></span><br><span class="line">  -h HOST, <span class="comment">--host HOST</span></span><br><span class="line">  -p PORT, <span class="comment">--port PORT</span></span><br><span class="line">  <span class="comment">--threaded</span></span><br><span class="line">  <span class="comment">--processes PROCESSES</span></span><br><span class="line">  <span class="comment">--passthrough-errors</span></span><br><span class="line">  -d, <span class="comment">--debug           enable the Werkzeug debugger (DO NOT use in production</span></span><br><span class="line">                        code)</span><br><span class="line">  -D, <span class="comment">--no-debug        disable the Werkzeug debugger</span></span><br><span class="line">  -r, <span class="comment">--reload          monitor Python files for changes (not 100&#123;'const':</span></span><br><span class="line">                        True, '<span class="keyword">help</span><span class="string">': '</span>monitor Python files <span class="keyword">for</span> changes (<span class="keyword">not</span></span><br><span class="line">                        <span class="number">100</span>% <span class="keyword">safe</span> <span class="keyword">for</span> production <span class="keyword">use</span>)<span class="string">', '</span>option_strings<span class="string">':</span></span><br><span class="line"><span class="string">                        ['</span>-r<span class="string">', '</span><span class="comment">--reload'], 'dest': 'use_reloader',</span></span><br><span class="line">                        <span class="string">'required'</span>: <span class="literal">False</span>, <span class="string">'nargs'</span>: <span class="number">0</span>, <span class="string">'choices'</span>: <span class="keyword">None</span>,</span><br><span class="line">                        <span class="string">'default'</span>: <span class="keyword">None</span>, <span class="string">'prog'</span>: <span class="string">'hello.py runserver'</span>,</span><br><span class="line">                        <span class="string">'container'</span>: &lt;argparse._ArgumentGroup <span class="keyword">object</span> <span class="keyword">at</span></span><br><span class="line">                        <span class="number">0x10bdd5090</span>&gt;, <span class="string">'type'</span>: <span class="keyword">None</span>, <span class="string">'metavar'</span>: <span class="keyword">None</span>&#125;afe <span class="keyword">for</span></span><br><span class="line">                        production <span class="keyword">use</span>)</span><br><span class="line">  -R, <span class="comment">--no-reload       do not monitor Python files for changes</span></span><br></pre></td></tr></table></figure></p>
<p>嗯，真的有很多，我们在这里无法一一去试。之前说过我们可以在运行服务器前在命令行中传入域名和端口等参数，现在我们就来试试。<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(venv) $ <span class="keyword">python</span> hello.<span class="keyword">py</span> runserver --host <span class="number">0.0</span>.<span class="number">0.0</span></span><br><span class="line"> * Running <span class="keyword">on</span> http://<span class="number">0.0</span>.<span class="number">0.0</span>:<span class="number">5000</span>/ (Press CTRL+C <span class="keyword">to</span> <span class="keyword">quit</span>)</span><br></pre></td></tr></table></figure></p>
<p>‘–host’这个参数用来指定Web服务器监听来自客户端的连接的网络接口。在默认情况下，Flask的开发服务器监听localhost上(即127.0.0.1)的连接，所以只接受来自服务器所在计算机发起的连接。上面这个命令让Web服务器监听公共网络接口上的连接，允许同网中的其它计算机连接服务器。所以，现在Web服务器可以使用<a href="http://0.0.0.0:5000/" target="_blank" rel="noopener">http://0.0.0.0:5000/</a> 网络中的任意一台电脑访问，其中‘0.0.0.0’就是服务器所在的计算机的外网IP地址。</p>
<p>Last: <a href="http://roseou.github.io/2016/05/13/context/" target="_blank" rel="noopener">Flask学习教程 Part1 2.2:请求与响应</a><br>Next: <a href="http://roseou.github.io/2016/05/16/templates/" target="_blank" rel="noopener">Flask学习教程 Part1 3.1:用Jinja2渲染模板</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在第一章关于Flask简介中就有提到过Flask很多高级功能都要通过扩展实现，这一节就来介绍一个Flask扩展，Flask-Script。这个扩展为Flask程序添加了一个命令行解析器，并自带了一组常用选项，它还支持自定义命令。&lt;/p&gt;
&lt;p&gt;Flask的开发服务器支持很多
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Flask学习教程 Part1 2.2:请求与响应</title>
    <link href="http://yoursite.com/2016/05/13/context/"/>
    <id>http://yoursite.com/2016/05/13/context/</id>
    <published>2016-05-13T12:00:37.000Z</published>
    <updated>2016-05-17T14:11:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>在这一节，会介绍Flask的一些设计理念：上下文、请求调度、请求钩子和响应。</p>
<h2 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h2><p>首先上下文是什么东西？</p>
<p>这里我想引用一下《flask web开发》里介绍上下文的一段话：</p>
<blockquote>
<p>Flask从客户端收到请求时，要让视图函数能访问一些对象，这样才能处理请求。请求对象就是一个很好的例子，它封装了客户端发送的HTTP请求。</p>
<p>要想让视图函数能够访问请求对象，一个显而易见的方式是将其作为参数传入视图函数，不过这会导致程序中的每个视图函数都增加一个参数。除了访问请求对象，如果视图函数在处理请求时还要访问其他对象，情况会变得更糟。</p>
<p>为了避免大量可有可无的参数把视图函数弄得一团糟，Flask使用上下文临时把某些对象变为全局可访问。有了上下文，就可以写出下面的视图函数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> request</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    user_agent = request.headers.get(<span class="string">'User-Agent'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Your browser is %s'</span> % user_agent</span><br></pre></td></tr></table></figure></p>
<p>注意在这个视图函数中我们如何把request当作全局变量使用。事实上，request不可能是全局变量。试想，在多线程服务器中，多个线程同时处理不同客户端发送的不同请求时，每个线程看到的request对象必然不同。Falsk使用上下文让特定的变量在一个线程中全局可访问，与此同时却不会干扰其他线程。</p>
</blockquote>
<p>我不知道该如何很官方的去解释上下文，我所理解的就是，通常我们所调用的函数不是一个单独完整的函数，我们只是在往框架上面添加函数，函数完成本身功能时，还得与框架的其他部分交互。当你运行一个程序或者说处理一个请求时，需要用到其他的一些外部变量，这就由上下文来提供。这可以理解为环境，就是你运行这个程序或者处理这个请求时，需要一个特定的环境。</p>
<p>每一段程序都有很多外部变量。这说明你这段程序是不完整的，不能独立运行。为了它正常运行，你就要给所有的外部变量一个一个赋值。而这些值的集合就叫上下文。它类似于一个全局变量吧,而这个变量的值会根据提供的值而改变。我们一般是写一个类，然后将程序运行时需要的配置文件写进这个类，当需要时再通过这个类来获取参数。</p>
<p>这个上下文跟语文阅读理解里的上下文也差不多。如果我不告诉你上下文，只随便给你一个句子，没有相关的语境，你也就无法理解它。文章需要语境，程序需要环境。</p>
<p>总之，上下文可以简单地理解为一个应用运行过程中或一次请求中的所有数据。</p>
<p>flask中有两种上下文全局变量：应用上下文，请求上下文。其中它们分别有current_app,g变量和request,session变量。这四个都是线程级的全局变量。</p>
<p>(应用上下文)对于应用，上下文包括：</p>
<ul>
<li>应用的启动脚本是哪个文件，启动时指定了哪些参数</li>
<li>加载了哪些配置文件，导入了哪些配置</li>
<li>连了哪个数据库</li>
<li>有哪些public的工具类、常量</li>
<li>应用跑在哪个机器上，IP多少，内存多大…</li>
<li>……</li>
</ul>
<p>(请求上下文)对于一次请求，则包括:</p>
<ul>
<li>请求的方法、地址、参数、post上来的数据、带上来的cookie…</li>
<li>当前的session</li>
<li>处理这个请求时创建出来的变量、对象…</li>
<li>……</li>
</ul>
<p><strong> 应用上下文 </strong><br>从一个Flask程序读入配置并启动开始，就进入了应用上下文，在其中我们可以访问配置文件、打开资源文件、通过路由规则反向构造URL等。</p>
<ul>
<li>current_app:表示当前激活程序的程序实例。</li>
<li>g:它是在处理请求时用作临时存储的对象。每次请求都会重设。</li>
</ul>
<p><strong> 请求上下文 </strong><br>当一个请求进入开始被处理时，就进入了请求上下文，在其中我们可以访问请求携带的信息，比如HTTP方法、表单域等。</p>
<ul>
<li>request(请求对象):封装了客户端发出的HTTP请求中的内容。</li>
<li>session(用户会话):用于储存请求之间需要“记住”的值，它是一个字典。</li>
</ul>
<p>要使用这四个变量，只要从flask中导入就可以：</p>
<figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> current_app</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> g</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> session</span><br><span class="line"></span><br><span class="line">＃可以直接从中获取内容，如：</span><br><span class="line">request.args</span><br><span class="line">request.forms</span><br><span class="line">request.cookies</span><br></pre></td></tr></table></figure>
<p>如果在使用这四个变量时我没有激活程序上下文或者请求上下文，就会导致错误。用current_app做例子，进入Python shell会话：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ python</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; from hello import app</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; from flask import current_app</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; current_app.name</span><br></pre></td></tr></table></figure>
<p>会报错：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Traceback(most recent <span class="keyword">call</span> <span class="keyword">last</span>):</span><br><span class="line">...</span><br><span class="line">RuntimeError: working outside <span class="keyword">of</span> application <span class="keyword">context</span></span><br></pre></td></tr></table></figure>
<p>要这样执行才不会报错：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; from hello import app           ＃从hello文件导入app实例</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; from flask import current_app   ＃从flask包导入current_app对象</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; app_ctx = app.app_context()     ＃获得一个程序上下文（激活程序上下文），实际上是创建了一个AppContext类的实例</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; app_ctx.push()                  ＃把程序上下文压入堆栈中</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; current_app.name                ＃当前激活程序的程序实例的名字</span><br><span class="line"><span class="string">'hello'</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; app_ctx.pop()                   ＃把上下文弹出</span><br></pre></td></tr></table></figure></p>
<h2 id="请求调度"><a href="#请求调度" class="headerlink" title="请求调度"></a>请求调度</h2><p>当客户端发送请求给程序时，Flask会在程序的URL映射中查找客户端所请求的URL，让程序找到处理该请求的视图函数。</p>
<p>上一节中也稍微介绍过URL映射，它就是Rl和视图函数之间的这种对应关系。在上一节的hello.py中，我们使用了app.route()装饰器生成映射。其实除了使用app.route()装饰器外，还可以使用app.add_url_rule()函数生成映射。</p>
<p>现在我们可以查看一下我们的hello.py程序所生成的映射。在Python shell中检查：<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(venv) $ python</span><br><span class="line">&gt;&gt;&gt; <span class="keyword">from</span> hello <span class="keyword">import</span> app</span><br><span class="line">&gt;&gt;&gt; app.url_map</span><br><span class="line">Map<span class="function"><span class="params">([&lt;Rule <span class="string">'/user/'</span> (HEAD, OPTIONS, GET) -&gt; user&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params"> &lt;Rule <span class="string">'/'</span> (HEAD, OPTIONS, GET) -&gt; index&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params"> &lt;Rule <span class="string">'/static/&lt;filename&gt;'</span> (HEAD, OPTIONS, GET) -&gt; static&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params"> &lt;Rule <span class="string">'/user/&lt;name&gt;'</span> (HEAD, OPTIONS, GET) -&gt; user&gt;])</span></span></span><br></pre></td></tr></table></figure></p>
<p>可以看到现在我们有四个URL映射。其中‘/’、’/user/‘和’/user/<name>‘这三个路由是在程序中使用app.route装饰器定义的。’/static/<filename>‘这个路由是Flask添加的特殊路由，用于访问静态文件，后面会说到。<br>URl映射中的HEAD、OPTIONS、GET叫做请求方法，Flask为每个路由都指定了请求方法，当不同的请求方法发送到相同的URl上时，会由不同的视图函数进行处理。默认情况下，路由只回应GET 请求，但是可以通过methods参数使用不同方法。因此，在这个程序中的这三个路由都使用GET方法。后面会介绍如何为路由指定不同的请求方法。</filename></name></p>
<blockquote>
<p>以下是一些比较常见的HTTP方法：</p>
<ul>
<li>GET：浏览器告诉服务器只要得到页面上的信息并发送这些信息。</li>
<li>HEAD：浏览器告诉服务器想要得到信息，但是只要得到信息头，不需要页面内容。Flask会自动处理这个方法。</li>
<li>POST：浏览器告诉服务器想要向URL发表一些新的信息，服务器必须确保数据被保存好且只保存了一次。 </li>
<li>PUT：与 POST 方法类似，不同的是服务器可能触发多次储存过程而把旧的值覆盖掉。假设在传输过程中连接丢失的情况下，一个处于浏览器和服务器之间的系统可以在不中断的情况下安全地接收第二次请求。在这种情况下，使用 POST 方法就无法做到了，因为它只被触发一次。</li>
<li>DELETE：删除给定位置的信息。</li>
<li>OPTIONS：为客户端提供一个查询URL支持哪些方法的捷径。Flask会自动处理这个方法。</li>
</ul>
</blockquote>
<h2 id="请求钩子"><a href="#请求钩子" class="headerlink" title="请求钩子"></a>请求钩子</h2><p>有时候我们需要经常在处理请求之前或之后执行同一段代码，例如，在请求开始时，我们可能需要创建数据库连接或者认证发起请求的用户。为了避免在每个视图函数中都使用重复的代码，Flask提供了注册通用函数功能，它们就是请求钩子。请求钩子可在请求被分发到视图函数之前或之后调用。</p>
<blockquote>
<p>请求钩子使用装饰器实现。Flask支持以下4种钩子。</p>
<ul>
<li>before_first_request：注册一个函数，在处理第一个请求之前运行。</li>
<li>before_request：注册一个函数，在每次请求之前运行。其中一个函数作出响应后，其它函数将不再调用。</li>
<li>after_request：注册一个函数，如果没有未处理的异常抛出，在每次请求之后运行。试图函数返回值会转换成一个实际响应对象交给它处理。</li>
<li>teardown_request：注册一个函数，即使有未处理的异常抛出，也在每次请求之后运行。</li>
</ul>
</blockquote>
<p>在请求钩子函数和视图函数之间共享数据一般使用上下文全局变量g。例如，before_request处理程序可以从数据库中加载已登陆用户，并将其保存到g.user中。随后调用试图函数时，试图函数再使用g.user获取用户。</p>
<h2 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h2><blockquote>
<p>Flask调用视图函数后，会将其返回值作为响应内容。大多数情况下，响应就是一个简单的字符串，作为HTML页面回送客户端。但HTTP协议需要的不仅是作为请求响应的字符串。HTTP响应中一个很重要的部分是状态吗，Flask默认为200，这个代码表明请求已经被成功处理。</p>
</blockquote>
<p>其实简单来说就是，Flask调用视图函数将该函数的返回值作为响应内容时，响应内容不仅仅是作为请求响应的字符串，还有状态码。这个状态码作为视图函数的第二个返回值，添加在响应文本后面。</p>
<p>不同的响应需要不同的状态码。我们所发出的请求往往不可能全部都成功响应，总会有发生错误的时候，例如当你请求了一个不存在的URL就会返回404状态码，当请求报文存在错误时就会返回400状态码。</p>
<p>下面我们来看一个例子：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@app.route(<span class="string">'/'</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span></span><span class="symbol">:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;h1&gt;Bad Request&lt;/h1&gt;, 400</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到第一个返回值是响应文本，第二个返回值是400状态码。这样当你请求访问程序根地址时，它就会返回400状态码表示请求无效。（注意：浏览器会像对待状态码200一样对待状态码400）</p>
<p>Last: <a href="http://roseou.github.io/2016/05/08/routing/" target="_blank" rel="noopener">Flask学习教程 Part1 2.1:路由和视图函数</a><br>Next: <a href="http://roseou.github.io/2016/05/15/script/" target="_blank" rel="noopener">Flask学习教程 Part1 2.3:使用Flask-Script扩展支持命令行选项</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在这一节，会介绍Flask的一些设计理念：上下文、请求调度、请求钩子和响应。&lt;/p&gt;
&lt;h2 id=&quot;上下文&quot;&gt;&lt;a href=&quot;#上下文&quot; class=&quot;headerlink&quot; title=&quot;上下文&quot;&gt;&lt;/a&gt;上下文&lt;/h2&gt;&lt;p&gt;首先上下文是什么东西？&lt;/p&gt;
&lt;p&gt;这
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Flask学习教程 Part1 2.1:路由和视图函数</title>
    <link href="http://yoursite.com/2016/05/08/routing/"/>
    <id>http://yoursite.com/2016/05/08/routing/</id>
    <published>2016-05-08T03:47:48.000Z</published>
    <updated>2017-04-28T07:12:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>这一章的重点是介绍路由与视图函数，但同时还会介绍一个完整的程序的基本结构。</p>
<p>那么我们来看一个完整的应用hello.py。在上一章中，我们创建了一个playwithflask文件夹，现在请在这个文件夹里创建一个hello.py文件，然后输入以下代码:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span>                               ＃这里是python定义函数的语法</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;h1&gt;Hello world!&lt;/h1&gt;'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/user/&lt;name&gt;')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">user</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;h1&gt;Hello, %s!&lt;/h1&gt;'</span> % name    ＃这里是python中使用格式转换符的语法</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run(debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></p>
<p>前端的同学，你们看不懂是吧？没关系，现在来解释一下这段python代码是什么意思，做了什么。</p>
<p>1.首先，我们之前下载安装了flask，现在就从flask包里导入Flask这个类，因为接下来要用到。这里涉及到python面向对象的知识，Flask类定义在flask里，它有着许多属性和方法（属性可以理解为一些特质，就像人类有眼耳口鼻，方法可以理解为行为，就像人类会说话会走路一样），现在你只要知道这些就够了。</p>
<p>2.然后，我们就创建一个Flask类的实例，它叫app。因为app是Flask类，所以它有着Flask类的属性和方法。Flask类里有着一个构造函数，当我们实例化Flask类创造app的时候，这个构造函数就会被调用，这个函数里有一个必须要传入的参数，就是程序主模块或包的名称。这个参数决定着程序的根目录。如果你使用单一的模块，你应该使用__name__ ，因为模块的名称将会因其作为单独应用启动还是作为模块导入而有不同（也就是‘__main__’或实际的导入名）。这里的hello.py就是一个单一的模块，所以使用__name__就好了。</p>
<p>3.接下来这两段代码就叫做<strong>路由</strong>。这里使用到了app实例里的route装饰器。装饰器又是什么？装饰器实际上也是一个函数，它是一个接受另一个函数作为参数的函数。也就是说，这里的:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@app.route(<span class="string">'/'</span>)<span class="symbol">:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span></span><span class="symbol">:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;h1&gt;Hello world!&lt;/h1&gt;'</span></span><br></pre></td></tr></table></figure></p>
<p>就相当于：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span></span><span class="symbol">:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;h1&gt;Hello world!&lt;/h1&gt;'</span></span><br><span class="line"></span><br><span class="line">app.route(<span class="string">'/'</span>, index)</span><br></pre></td></tr></table></figure></p>
<p>所以说route装饰器也是一个函数，至于它怎么定义的现在你不用管，你只要知道它的作用就够了。它的作用就是将URL和函数绑定。当在浏览器请求这个URL时，与之绑定的函数就会被调用，然后函数的返回值会发送给浏览器。而这个与URL绑定了的函数就叫做<strong>视图函数</strong>。而URl和视图函数之间的这种对应关系叫URL映射，这会在下一节中详细介绍。</p>
<p>4.好，看回hello.py里的第二个路由，它有点特别，它是一个<strong>动态路由</strong>。看到后面那个<name>了吧，这个叫通配符，就是它可以随着你传入的值而变动，是一个动态的部分。调用视图函数时，Flask会将动态部分作为参数传入函数，然后返回给浏览器。</name></p>
<p>5.最后的app.run()的意思是调用run()函数，让hello.py运行在本地服务器上，可以把指定的域名和端口作为参数传入。if__name__==’__main__‘的意思是，当这个hello.py被Python解释器直接执行的时候才会运行服务器，作为模块导入时就不会。debug=True的意思就是将run()函数里的debug参数的值设置为True，表示启用调试模式（在调试模式下，程序运行时被修改会自动重载）。</p>
<p>嗯，终于弄明白这段代码了。来运行这个程序看看。<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(venv) $ <span class="keyword">python</span> hello.<span class="keyword">py</span></span><br><span class="line"> * Running <span class="keyword">on</span> http://<span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">5000</span>/ (Press CTRL+C <span class="keyword">to</span> <span class="keyword">quit</span>)</span><br><span class="line"> * Restarting with stat</span><br><span class="line"> * Debugger <span class="keyword">is</span> active!</span><br><span class="line"> * Debugger pin code: <span class="number">246</span>-<span class="number">018</span>-<span class="number">741</span></span><br></pre></td></tr></table></figure></p>
<p>现在这个程序运行在本地的服务器上了，那么现在打开浏览器，在地址栏输入<a href="http://127.0.0.1:5000/" target="_blank" rel="noopener">http://127.0.0.1:5000/</a> ， 然后我们就会看到：<br><img src="/images/world.jpg"><br>这里访问了’/‘，即程序的根地址，于是调用了index()视图函数，即第一个路由。</p>
<p>如果我们输入<a href="http://127.0.0.1:5000/user/rose/" target="_blank" rel="noopener">http://127.0.0.1:5000/user/rose/</a> ， 那么就会看到：<br><img src="/images/user.jpg"><br>这里访问了’/user/rose’，用到了第二个路由，并且给name这个动态参数传入了rose这个值。</p>
<p>至此，路由和试图函数的部分就介绍完了。实际上，在本章不仅仅介绍了路由和试图函数，而把把一个完整的程序的基本结构都介绍了一遍。</p>
<p>Last: <a href="http://roseou.github.io/2016/05/08/setup/" target="_blank" rel="noopener">Flask学习教程 Part1 1:Flask简介及安装</a><br>Next: <a href="http://roseou.github.io/2016/05/13/context/" target="_blank" rel="noopener">Flask学习教程 Part1 2.2:请求与响应</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这一章的重点是介绍路由与视图函数，但同时还会介绍一个完整的程序的基本结构。&lt;/p&gt;
&lt;p&gt;那么我们来看一个完整的应用hello.py。在上一章中，我们创建了一个playwithflask文件夹，现在请在这个文件夹里创建一个hello.py文件，然后输入以下代码:&lt;br&gt;&lt;f
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Flask学习教程 Part1 1:Flask简介及安装</title>
    <link href="http://yoursite.com/2016/05/08/setup/"/>
    <id>http://yoursite.com/2016/05/08/setup/</id>
    <published>2016-05-08T03:37:26.000Z</published>
    <updated>2016-05-17T14:15:46.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Flask-简介"><a href="#Flask-简介" class="headerlink" title="Flask 简介"></a>Flask 简介</h3><p>Flask是一个使用 Python 编写的轻量级 Web 应用框架。它有两个主要的依赖：</p>
<ul>
<li>Jinja2:它是一个基于Python的模版引擎，提供了模板系统。其设计思想来源于Django的模板引擎。&gt;详情到<a href="http://docs.jinkan.org/docs/jinja2/" target="_blank" rel="noopener">Jinja2中文官方文档</a>和<a href="http://jinja.pocoo.org/docs/dev/" target="_blank" rel="noopener">Jinja2英文官方文档</a></li>
<li>Werkzeug:它是一个Python的WSGI规范的实用函数库。提供了路由、调试和Web服务器网关接口（WSGI）子系统。详情到<a href="http://werkzeug-docs-cn.readthedocs.io/zh_CN/latest/" target="_blank" rel="noopener">Werkzeug中文官方文档</a>和<a href="http://werkzeug.pocoo.org/docs/0.11/" target="_blank" rel="noopener">Werkzeug英文官方文档</a></li>
</ul>
<p>Flask本身没有提供数据库访问模块和orm不原生支持数据库访问、也不支持Web表单验证和用户认证等高级功能。这些功能都要通过扩展实现。</p>
<h3 id="Flask-安装"><a href="#Flask-安装" class="headerlink" title="Flask 安装"></a>Flask 安装</h3><p>一个又方便又整洁的方法就是使用虚拟环境安装啦，虚拟环境用一个叫virtualenv的工具创建（详情可到<a href="https://virtualenv.pypa.io/en/latest/index.html" target="_blank" rel="noopener">virtualenv官网</a>。）</p>
<p>可以先看看自己的系统中有没有virtualenv：<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ virtualenv <span class="comment">--version</span></span><br></pre></td></tr></table></figure></p>
<p>如果没有显示版本号，就需要去安装。</p>
<p>要安装virtualenv需要用到pip，所以我们要先在全局安装pip。</p>
<p>Mac OS X下：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>sudo easy_install pip</span><br></pre></td></tr></table></figure></p>
<p>linux下：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-<span class="builtin-name">get</span> install python-pip</span><br></pre></td></tr></table></figure></p>
<p>windows下:</p>
<ul>
<li>方法一：换mac</li>
<li>方法二：换linux系统</li>
<li><p>方法三：</p>
<ul>
<li>1.先进入<a href="https://svn.apache.org/repos/asf/oodt/tools/oodtsite.publisher/trunk/distribute_setup.py" target="_blank" rel="noopener"> 这里 </a>,复制所有代码粘贴到distribute_setup.py里，请将这个文件放到你想放的地方。</li>
<li><p>2.然后打开Windows PowerShell，cd到distribute_setup.py所在的目录下，运行distribute_setup.py。</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">python</span> distribute_setup.<span class="keyword">py</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>3.接下来，就要把你的Python安装中的Scripts文件夹的路劲添加到PATH环境变量中，这样easy_install命令和其它Python脚本就加入到了命令行自动搜索的路径。步骤是：右键单击“我的电脑”图标，选择“属性”，然后单击“高级系统设置”，再单击”环境变量”按钮，最后双击“系统变量”栏中的“Path”变量，并加入你的Python解释器的Scripts文件夹的路径。确保你用分号把它和现有的值分隔开。假设你使用Python 2.7且为默认目录，添加下面的值:</p>
<figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;C:<span class="symbol">\P</span>ython27<span class="symbol">\S</span>cripts</span><br></pre></td></tr></table></figure>
</li>
<li><p>4.这样，我们就可以使用easy_install了。重启一下Windows PowerShell，用easy_install来安装pip：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">easy_install</span> pip</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>啊啊，终于装好pip了，所以还是推荐使用方法一噢。然后，我们来使用pip安装virtualenv，一句搞定：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip <span class="keyword">install</span> virtualenv</span><br></pre></td></tr></table></figure></p>
<p>安装好virtulaenv了，接着创建一个文件夹来放‘教程’的实例代码。这里我创建了一个叫playwithflask的文件夹，然后进入到这个文件夹中。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir playwithflask</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> playwithflask</span></span><br></pre></td></tr></table></figure></p>
<p>接下来使用virtualenv命令来创建Python虚拟环境。<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>virtualenv venv</span><br></pre></td></tr></table></figure></p>
<p>virtulenv命令后只有一个必须的参数，就是虚拟环境的名字，一般命名为venv。也可以叫其它名字，只要你喜欢。</p>
<p>如果这样显示：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">New python executable <span class="keyword">in</span> <span class="regexp">/Users/</span>rose<span class="regexp">/rose/</span>playwithflask<span class="regexp">/venv/</span>bin/python</span><br><span class="line">Installing setuptools, pip, wheel...done.</span><br></pre></td></tr></table></figure></p>
<p>就证明你创建好了。并且可以看到用virtualenv创建虚拟环境时还自动安装了setuptools、wheel等工具。</p>
<p>创建完虚拟环境后，playwithflask文件夹里就会出现一个venv文件夹(或者是你起的其它名字)。和虚拟环境相关的文件都会保存在这个文件夹中，它保存一个全新的虚拟环境，其中还有一个私有的Python解释器。</p>
<p>每次使用这个虚拟环境前，都要先激活：</p>
<p>Mac OS X 和 Linux 下：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">source</span> venv<span class="regexp">/bin/</span>activate</span><br></pre></td></tr></table></figure></p>
<p>Windows下：</p>
<ul>
<li>方法一：换mac</li>
<li>方法二：换linux系统</li>
<li>方法三：<figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ venv<span class="symbol">\S</span>cripts<span class="symbol">\a</span>ctivate</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>激活虚拟环境后，venv文件夹里的Python解释器的路径就会被添加进PATH中，但这只在当前命令行会话有效，所以每次使用虚拟环境前都要先激活它。接下来我们会看到命令行提示符前加入了虚拟环境的名字：<br><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(venv) <span class="symbol">$</span></span><br></pre></td></tr></table></figure></p>
<p>如果要回到全局Python解释器中，就这样：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>deactivate</span><br></pre></td></tr></table></figure></p>
<p>(其实还可以先安装virtualenv，然后创建虚拟环境，创建虚拟环境的同时会在这个坏境下自动安装pip。)</p>
<p>接下来，终于到flask的安装了。激活虚拟环境后，用pip来安装：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(venv) $ pip <span class="keyword">install</span> flask</span><br></pre></td></tr></table></figure></p>
<p>安装flask的过程中，可以看到它还自动安装了Werkzeug,MarkupSafe,Jinja2,itsdangerous这些依赖。</p>
<p>然后来验证一下你是否成功安装了flask。启动python解释器，导入Flask：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(venv) $ python</span><br><span class="line">Python 2.7.10 (default, Oct 23 2015, 18:05:06)</span><br><span class="line">[GCC 4.2.1 Compatible Apple LLVM 7.0.0 (clang-700.0.59.5)] on darwin</span><br><span class="line">Type <span class="string">"help"</span>, <span class="string">"copyright"</span>, <span class="string">"credits"</span> <span class="keyword">or</span> <span class="string">"license"</span> <span class="keyword">for</span> more information.</span><br><span class="line">&gt;&gt;&gt; import flask</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></p>
<p>如果导入Flask时没有报错，就证明你安装成功了。</p>
<p>那么接下来终于可以开始学习flask了。</p>
<p>Next: <a href="http://roseou.github.io/2016/05/08/routing/" target="_blank" rel="noopener">Flask学习教程 Part1 2.1:路由和视图函数</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Flask-简介&quot;&gt;&lt;a href=&quot;#Flask-简介&quot; class=&quot;headerlink&quot; title=&quot;Flask 简介&quot;&gt;&lt;/a&gt;Flask 简介&lt;/h3&gt;&lt;p&gt;Flask是一个使用 Python 编写的轻量级 Web 应用框架。它有两个主要的依赖：&lt;/
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Bottle 总结</title>
    <link href="http://yoursite.com/2016/03/27/bottle/"/>
    <id>http://yoursite.com/2016/03/27/bottle/</id>
    <published>2016-03-27T05:51:14.000Z</published>
    <updated>2016-04-27T13:24:55.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>“Bottle是一个快速，简单，轻量级的Python WSGI Web框架。它小巧但高效，整个框架只有一个文件，却自带了路径映射（route）、模板（template）、简单的数据库访问（post，get等）等web框架组件。它只依赖Python标准库。”</p>
</blockquote>
<ul>
<li>URL映射（Routing）：将URL请求映射到Python函数。</li>
<li>模板（Templates）：内置了一个简单快速的模板引擎,并支持其他模板引擎，如Mako,Jinja2，cheetah等</li>
<li>实用工具（Utilities）:内置了很多工具来提供表单数据的访问,文件上传,Cookies处理,HTTP头信息处理和访问其他HTTP相关信息的功能.）</li>
<li>服务器（Server）：Bottle内置了一个用于开发环境的Web服务器，在生产环境下还支持paste,gae,Google App Engine,cherrypy等符合WSGI标准的HTTP服务器。</li>
</ul>
<blockquote>
<p>成熟的web框架应该有：基本HTTP请求处理、GET或POST数据的接受、模板、数据库、session等功能。</p>
</blockquote>
<p>可是bottle并没有提供配置文件集成，数据库管理，可扩展的中间件等特性，所以它并不是开发复杂项目的第一选择。对于大型的Web程序，Bottle的功能略显不足，程序员需要手动管理模块、数据库、配置等等。</p>
<p>而如果你只是想快速创建一个Restful API接口，或者只想用网络开发框架的做一个简单的应用，Bottle可以轻松地满足你的要求。它具备了你将需要的所有功能：路由、模板、访问请求与响应数据、支持多种网络服务器以及WebSockets等高级功能。</p>
<h2 id="关于安装"><a href="#关于安装" class="headerlink" title="关于安装"></a>关于安装</h2><p>前面说到它小巧，它的小巧从安装就能看出来。（在虚拟环境下）</p>
<p>首先你可以选择安装它：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>pip install bottle==<span class="number">0</span>.<span class="number">12.8</span></span><br><span class="line"><span class="variable">$ </span>pip freeze &gt; requirements.txt</span><br></pre></td></tr></table></figure>
<p>你也可以不安装它，直接下载bottle.py文件复制到自己的应用中就可以使用了。</p>
<pre><code>$ wget http://bottlepy.org/bottle.py
</code></pre><h2 id="项目构建"><a href="#项目构建" class="headerlink" title="项目构建"></a>项目构建</h2><p>好像没有构建项目的必要，但如果你非要构建的话，这里有一个第三方开发的插件bottle-boilerplate可用来自动构建项目（这个插件star也不多..）。</p>
<p>首先来安装它：</p>
<pre><code>$ pip install bottle-boilerplate
</code></pre><p>然后就可以构建项目了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> bottle startproject YOUR_PROJECT_NAME</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> YOUR_PROJECT_NAME</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> pip install -r requirements.txt</span></span><br></pre></td></tr></table></figure>
<p>然后就可以看到这个项目结构是这样的（这里我创建了bottle文件夹来放我的项目，我的项目名为bottleapp）：</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">|- bottle</span></span><br><span class="line">	<span class="string">|- bottleapp</span></span><br><span class="line">		<span class="string">|- bottleapp</span></span><br><span class="line">			<span class="string">|- controllers</span></span><br><span class="line">				<span class="string">|- home.py</span></span><br><span class="line">				<span class="string">|- __init__.py</span></span><br><span class="line">			<span class="string">|- models</span></span><br><span class="line">				<span class="string">|- __iniy__.py</span></span><br><span class="line">			<span class="string">|- views</span></span><br><span class="line">				<span class="string">|- index.html</span></span><br><span class="line">			<span class="string">|- __init__.py</span></span><br><span class="line">			<span class="string">|- routes.py</span></span><br><span class="line">			<span class="string">|- settings.py</span></span><br><span class="line">		<span class="string">|- tests</span></span><br><span class="line">			<span class="string">|- __init__.py</span></span><br><span class="line">		<span class="string">|- manage.py</span></span><br><span class="line">		<span class="string">|- README.rst</span></span><br><span class="line">		<span class="string">|- requirements.txt</span></span><br><span class="line">	<span class="string">|- venv</span></span><br><span class="line">	<span class="string">|- requirements.txt</span></span><br></pre></td></tr></table></figure>
<p>你已经可以运行它试一下,但这时候只能看到一个404的错误页面：</p>
<pre><code>$ python -m bottle bottleapp
</code></pre><p>讲真似乎真的没有构建项目的必要..</p>
<h2 id="视图函数和路由"><a href="#视图函数和路由" class="headerlink" title="视图函数和路由"></a>视图函数和路由</h2><p>Bottle内置了一个强大的route引擎，可以给每个浏览器请求找到正确的回调函数。</p>
<p>先来看一个小小的Hello World:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bottle <span class="keyword">import</span> route,run</span><br><span class="line"><span class="meta">@route('/hello')     </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="keyword">return</span> <span class="string">"Hello World!"</span></span><br><span class="line">run(host=<span class="string">'localhost'</span>, port=<span class="number">8080</span>,debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>在浏览器请求一个URL时，框架自动调用与之相应的函数，将函数的返回值发送给浏览器。这里route()函数将“/hello”这个URL地址绑定到“hello（）”这个函数上，任何对“/hello”这个URL的请求都被递交到这个函数中。</p>
<p>run()启动了内置的开发服务器,把指定的域名和端口作为参数传入。它监听localhost的8080端口并响应请求.但它不能满足生产环境的需求。</p>
<p>Bottle的这种URL地址映射方法其实与flask差不多，也是使用了装饰器将函数和URL进行绑定的方法。</p>
<p>上面的route()函数将一个URL路径与一个回调函数关联起来,然后在默认应用中添加了一个URL映射(route).你也可以在你的应用中多添加几个路由器。因为一个回调函数可绑定多个route。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@route</span>(<span class="string">'/'</span>)</span><br><span class="line"><span class="variable">@route</span>(<span class="string">'/hello/&lt;name&gt;'</span>)</span><br><span class="line">def greet(name=<span class="string">'Stranger'</span>):</span><br><span class="line">	return <span class="string">'Hello %s!'</span> % name</span><br></pre></td></tr></table></figure>
<p>如果有一个URL没有被绑定到任何回调函数上，Bottle将返回“404 Page Not Found”的错误页面。</p>
<p>上面的栗子使用了模块层面的route()装饰器函数来定义route,这样,所有route都会添加到一个全局的”默认应用”,它是一个Bottle的实例，第一次调用route()时候会自动创建。</p>
<p>这使其他几个模块层面的修饰器函数都与这个”默认应用”有关.为了避免使用全局范围的”默认应用”,我们可以创建一个独立的应用对象.**</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bottle <span class="keyword">import</span> Bottle,run</span><br><span class="line">app = Bottle()    <span class="comment">#创建了一个Bottle对象app，然后所有函数都会映射到app的URL地址上</span></span><br><span class="line"><span class="meta">@app.route('/hello')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="keyword">return</span> <span class="string">"Hello World!"</span></span><br><span class="line">run(app, host=<span class="string">'localhost'</span>, port=<span class="number">8080</span>)</span><br></pre></td></tr></table></figure>
<p>这样别人就可以安全地导入你的app，然后通过Bottle.mount()方法合并到他的应用中。</p>
<p><strong>调试模式：</strong></p>
<pre><code>bottle.debug(True)
</code></pre><p><strong>自动重载：</strong></p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bottle import run</span><br><span class="line"><span class="builtin-name">run</span>(<span class="attribute">reloader</span>=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<h3 id="动态路由："><a href="#动态路由：" class="headerlink" title="动态路由："></a>动态路由：</h3><p>动态路由就是有通配符的路由,它能匹配多个URL地址.URL中的通配符会当作参数传给回调函数,直接在回调函数中使用.在同一个route里面，这个变量名需要是唯一的。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@route(<span class="string">'/hello/&lt;name&gt;'</span>)  <span class="comment">#旧语法中为:name</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(name = <span class="string">'World'</span>)</span></span>:  <span class="comment">#这里定义了一个默认参数</span></span><br><span class="line">	<span class="keyword">return</span> <span class="string">'Hello &#123;&#125;!'</span>.format(name)</span><br></pre></td></tr></table></figure>
<p><strong>过滤器：</strong></p>
<p>过滤器(Filter)可被用来定义特殊类型的通配符。在通配符传递给回调函数前,先自动转换通配符类型.包含过滤器的通配符定义一般像这样<name:filter>或<name:filter:config>.config部分可选,由被使用的过滤器决定。以下是几种过滤器:</name:filter:config></name:filter></p>
<blockquote>
<p>:int          匹配一个整形,自动将其转换为int类型.<br>:float        匹配一个浮点数，自动将其转换为float<br>:path         匹配所有字符，包含”/“<br>:re[:config]  允许在config中写一个正则表达式.</p>
</blockquote>
<p><strong> HTTP请求方法 </strong></p>
<p>在Bottle中，未指明请求访问的路由会默认使用GET方法.要处理如POST,PUT或者DELETE等等的其它请求，必须主动地在route()函数中添加它们，或者使用装饰器：@get(),@post()等等.</p>
<p>举一个用POST方法实现用户登录的栗子:</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bottle import get, post, request</span><br><span class="line">@get(<span class="string">'/login'</span>)    #或@route(<span class="string">'/login'</span>, <span class="function"><span class="keyword">method</span> = '<span class="title">GET</span>')</span></span><br><span class="line"><span class="function"><span class="title">def</span> <span class="title">login_form</span><span class="params">()</span>:</span></span><br><span class="line">	return <span class="string">'''&lt;form method="POST" action="/login"&gt;</span></span><br><span class="line"><span class="string">				&lt;input name="name" type="text" /&gt;</span></span><br><span class="line"><span class="string">				&lt;input name="password" type="password" /&gt;</span></span><br><span class="line"><span class="string">				&lt;input type="submit" /&gt;</span></span><br><span class="line"><span class="string">			  &lt;/form&gt;'''</span></span><br><span class="line">			  </span><br><span class="line">@post(<span class="string">'/login'</span>)  #或@route(<span class="string">'/login'</span>, <span class="function"><span class="keyword">method</span> = '<span class="title">POST</span>')</span></span><br><span class="line"><span class="function"><span class="title">def</span> <span class="title">login_submit</span><span class="params">()</span>:</span></span><br><span class="line">	name = request.forms.get(<span class="string">'name'</span>)</span><br><span class="line">	password = request.forms.get(<span class="string">'password'</span>)</span><br><span class="line">	<span class="keyword">if</span> check_login(name, password):</span><br><span class="line">		return <span class="string">'&lt;p&gt;Your login was correct&lt;/p&gt;'</span></span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		return <span class="string">'&lt;p&gt;Login failed&lt;/p&gt;'</span></span><br></pre></td></tr></table></figure>
<p>在这个栗子中，/login绑定了两个回调函数，一个回调函数响应GET请求，另一个响应POST请求。若浏览器用GET请求访问/login，则调用login_form()来返回登录界面，浏览器用POST方法提交表单后，调用login_submit()函数来检查用户有效性，并返回登录结果。</p>
<p><strong> 静态文件 </strong><br>Bottle内置的服务器不会自动处理像图片或CSS文件的静态文件请求。你需要给静态文件提供一个路由（告诉服务器哪些文件需要服务），一个回调函数（用来查找和控制静态文件的访问。）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bottle <span class="keyword">import</span> static_file</span><br><span class="line"><span class="meta">@route('/static/&lt;filename&gt;')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">server_static</span><span class="params">(filename)</span>:</span></span><br><span class="line">	<span class="keyword">return</span> static_file(filename,root=<span class="string">'/path/to/your/static/files'</span>)</span><br></pre></td></tr></table></figure>
<p>static_file()函数用来返回静态文件请求，上面的示例中，我们只返回”/path/to/your/static/files”路径下的文件，如果我们想要响应“/path/to/your/static/files”目录的子目录下的文件请求，那么我们可以使用一个格式化的通配符：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@route(<span class="string">'/static/&lt;filepath:path&gt;'</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">server_static</span><span class="params">(filepath)</span></span><span class="symbol">:</span></span><br><span class="line">       <span class="keyword">return</span> static_file(filepath, root=<span class="string">'/path/to/your/static/files'</span>)</span><br></pre></td></tr></table></figure>
<p>使用root=’./static/files’这样的相对路径时，注意当前工作目录（./）不一定是项目文件夹。</p>
<p><strong> 错误页面 </strong><br>如果任何请求的URL没有的到匹配的回调函数，Bottle会返回一个默认的错误页面，提供足够的debug信息。你也可以用error()设置自己的相关回调函数，自定义错误页面：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bottle <span class="keyword">import</span> error</span><br><span class="line"><span class="meta">@error(404)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">error404</span><span class="params">(error)</span>:</span></span><br><span class="line">	<span class="keyword">return</span> <span class="string">'Nothing here, sorry!'</span></span><br></pre></td></tr></table></figure>
<p>这里传给error404函数的唯一参数是一个HTTPError对象的实例。除此，这个回调函数与我们用来响应普通请求的回调函数没有不同。你可以从request中读取数据，往response中写入数据和返回所有HTTPError支持的数据类型。<br>只有在你的应用返回或raise一个HTTPError异常的时候，处理Error的函数才会被调用。更改Request，status或返回HTTPResponse不会触发错误处理函数。</p>
<h2 id="前端模板"><a href="#前端模板" class="headerlink" title="前端模板"></a>前端模板</h2><p>Bottle内置了一个快速且强大的模板引擎，SimpleTemplateEngine(stpl)。你可以使用template（）函数或者view（）装饰器来渲染一个模板，（这两个函数默认调用的模板引擎就是SimpleTemplate）你只要提供模板的名字和传递给模板的变量，下面是一个简单的栗子：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@route</span>(<span class="string">'/hello'</span>)</span><br><span class="line"><span class="variable">@route</span>(<span class="string">'/hello/&lt;name&gt;'</span>):</span><br><span class="line">def hello(name=<span class="string">'World'</span>):</span><br><span class="line">	return template(<span class="string">'hello_template'</span>, name=name)</span><br></pre></td></tr></table></figure>
<p>这将加载hello_template.tpl模板文件，并提供name变量，并渲染它，再将结果返回给浏览器。默认情况，Bottle会在./views/查找模板文件。你可以在bottle.TEMPLATE_PATH这个列表中添加模板路径。</p>
<p>view()装饰器允许你在回调函数中返回一个字典，并将其传递给模板。来一个栗子：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@route</span>(<span class="string">'/hello'</span>)</span><br><span class="line"><span class="variable">@route</span>(<span class="string">'/hello/&lt;name&gt;'</span>)</span><br><span class="line"><span class="variable">@view</span>(<span class="string">'hello_template'</span>)</span><br><span class="line">def hello(name=<span class="string">'World'</span>):</span><br><span class="line">	return dict(name=name)</span><br></pre></td></tr></table></figure>
<h4 id="SimpleTemplate的语法"><a href="#SimpleTemplate的语法" class="headerlink" title="SimpleTemplate的语法"></a>SimpleTemplate的语法</h4><p>python对空白敏感的语法使它很难作为一个模板语言。SimpleTemplate移除了一些限制。SimpleTemplate模板会被编译为python字节码，且在每次通过SimpleTemplate.render()渲染时执行。<br>注意：编译模板和渲染模板是两件事。通常模板只会被编译一次，然后会被缓存起来，但是会根据不同的参数，被多次渲染。</p>
<p><strong>内嵌语句</strong><br>只要在括号中的python语句返回一个字符串或有一个字符串的表达形式，它就是一个有效的语句。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>template(<span class="string">'Hello &#123;&#123;name&#125;&#125;!'</span>, name=<span class="string">'World'</span>)</span><br><span class="line"><span class="string">u'Hello World!'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>template(<span class="string">'Hello &#123;&#123;name.title() if name else "stranger"&#125;&#125;!'</span>, name=<span class="literal">None</span>)</span><br><span class="line"><span class="string">u'Hello stranger!'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>template(<span class="string">'Hello &#123;&#123;name.title() if name else "stranger"&#125;&#125;!'</span>, name=<span class="string">'mArC'</span>)</span><br><span class="line"><span class="string">u'Hello Marc!'</span></span><br></pre></td></tr></table></figure>
<p>括号中的python语句会在渲染的时候被执行，可访问传递给SimpleTemplate.render()方法的所有参数。默认情况下，它会自动转义HTML标签以防止XSS攻击。可在语句前加上“！”来关闭自动转义。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;template(<span class="string">'Hello &#123;&#123;name&#125;&#125;!'</span>, name=<span class="string">'&lt;b&gt;World&lt;/b&gt;'</span>)</span><br><span class="line"><span class="string">u'Hello &amp;lt;b&amp;gt;World&amp;lt;/b&amp;gt;!'</span></span><br><span class="line">&gt;&gt;&gt;template(<span class="string">'Hello &#123;&#123;!name&#125;&#125;!'</span>, name=<span class="string">'&lt;b&gt;World&lt;/b&gt;'</span>)</span><br><span class="line"><span class="string">u'Hello &lt;b&gt;World&lt;/b&gt;!'</span></span><br></pre></td></tr></table></figure>
<p><strong>嵌入python代码</strong></p>
<p>这个模板的语法类似于python的语法，它会确保语句块的正确缩进，所以你在写模板时不用担心缩进问题。</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">%if</span><span class="built_in"> name</span> == <span class="string">'World'</span>:</span><br><span class="line">	<span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span> Hello </span><span class="xquery">&#123;<span class="built_in">&#123;name</span>&#125;</span><span class="xml">&#125; <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">	<span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span> This is a test.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="meta">%else:</span></span><br><span class="line">	<span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello </span><span class="xquery">&#123;<span class="built_in">&#123;name</span>.title()&#125;</span><span class="xml">&#125;！<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">	<span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>How are you?<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="meta">%end</span></span><br></pre></td></tr></table></figure>
<p>一行以%开头，表明这一行是python代码。它和真正的python代码唯一的区别，在于你需要显式地在末尾添加%end语句，表明一个代码块结束。这样你就不必担心python代码中的缩进问题，SimpleTemplate模板引擎帮你处理了。不以%开头的行被当作普通文本来渲染。</p>
<p>只有在行首的%字符才有意义，可以使用%%来转义。</p>
<p>注意：模板在经过编译后会缓存在内存中，所以你在修改模板文件后，要调用bottle.TEMPLATES.clear()函数手工清除缓存，才能看到效果。而在debug模式下，缓存会被禁用，于是就无需手动清除缓存。</p>
<p><strong>防止换行</strong><br>在一行代码前面加上\来防止换行。</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;span&gt;\\</span><br><span class="line"><span class="tag">%<span class="selector-tag">if</span></span> True:</span><br><span class="line">nobreak\\</span><br><span class="line"><span class="tag">%<span class="selector-tag">end</span></span></span><br><span class="line">&lt;/span&gt;</span><br></pre></td></tr></table></figure>
<p>该模板会输出：</p>
<pre><code>&lt;span&gt;nobreak&lt;/span&gt;
</code></pre><p><strong>模板继承</strong></p>
<ul>
<li>%include语句</li>
</ul>
<p>可使用%include sub——template[kwargs]语句来包含其他模板。sub_template参数是模板的文件名或路径。[kwargs]部分是以逗号分开的键值对，是传给其他模板的参数。</p>
<figure class="highlight mojolicious"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span><span class="perl">%include header_template title=<span class="string">'Hello World!'</span></span><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span><span class="perl">%include footer_template</span><span class="xml"></span></span><br></pre></td></tr></table></figure>
<ul>
<li>%rebase语句</li>
</ul>
<p>%rebase base_template [kwargs]语句会渲染base_template这个模板，而不是原先的模板。然后base_template中使用一个空%include语句来包含原先的模板，并可访问所有通过kwargs传过来的参数。这样就可用模板来封装另一个模板，或是模拟引擎中的继承机制。**<br>假设现在有一个与内容有关的模板，想在它上面加一层普通的HTML层。为了避免include一堆模板，可以用一个基础模板。</p>
<p>名为layout.tpl的基础模板</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span><span class="xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml">	</span><span class="xml"><span class="tag">&lt;<span class="name">title</span>&gt;</span></span><span class="xquery">&#123;&#123;title <span class="keyword">or</span> <span class="string">'No title'</span>&#125;</span><span class="xml">&#125;<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><span class="xml"></span></span><br><span class="line"><span class="xml"></span><span class="xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml">	%include</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>名为 content.tpl的主模板</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">This is the<span class="built_in"> page </span>content:&#123;&#123;content&#125;&#125;</span><br><span class="line">%rebase layout <span class="attribute">title</span>=<span class="string">'Content Title'</span></span><br></pre></td></tr></table></figure>
<p>然后来渲染content.tpl</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print template(<span class="string">'content'</span>, content=<span class="string">'Hello World!'</span>)</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span><span class="xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml">	</span><span class="xml"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Content Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><span class="xml"></span></span><br><span class="line"><span class="xml"></span><span class="xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml">	This is the page content:Hello World!</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p><strong>模板内置函数</strong><br>在模板中访问一个未定义的变量会导致NameError异常，并立即终止模板的渲染。在抛出异常前，你无法检查变量是否被定义。当你想让输入更灵活或想在不同情况下使用同一个模板时，就很烦人了。SimpleTemplate模板引擎内置了三个函数来解决这个问题。</p>
<blockquote>
<p>defined(name):如果变量已定义则返回True，反之返回False<br>get(name,default=None):返回该变量，或一个默认值<br>setdefault(name,default):如果该变量未定义，则定义它，赋一个默认值，返回该变量</p>
</blockquote>
<p>下面这个栗子使用了这些函数，实现了模板中的可选参数：</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">% setdefault(<span class="string">'text'</span>,<span class="string">'No Text'</span>)</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><span class="xquery">&#123;&#123;get(<span class="string">'title'</span>,<span class="string">'No Title'</span>)&#125;</span><span class="xml">&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span> </span><span class="xquery">&#123;&#123; <span class="type">text</span> &#125;</span><span class="xml">&#125; <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">% <span class="keyword">if</span> defined(<span class="string">'author'</span>):</span><br><span class="line">	<span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>By </span><span class="xquery">&#123;&#123; author &#125;</span><span class="xml">&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">% <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>Bottle没有orm，没有专门封装数据库操作，不能直接支持数据库，需要通过一些插件实现。</p>
<p>如果你确实想在你的应用里使用数据库，寻求ORM支持，你可以选择使用SQLAlchemy,PyMongo,MongoEngine, CouchDB等。</p>
<p>所以如果你需要开发基于数据库的网站，且数据库的结构不会经常变化，那最好使用大型Python Web框架。而如果你的网站使用的是关系数据库，就可以不使用大型框架，直接用bottle、flask这类框架结合关系数据库模块就行。</p>
<p><strong> Key/Value数据库 </strong><br>Bottle通过bottle.db模块变量提供一个key/value数据库.存储的对象类似dict字典,keys和values必须是字符串.不支持items()，values()这些方法.</p>
<p><strong>bottle-mysql</strong></p>
<pre><code>$ pip install bottle-mysql
</code></pre><p>“Bottle-MySQL is a plugin that integrates MySQL with your Bottle application. It automatically connects to a database at the beginning of a request, passes the database handle to the route callback and closes the connection afterwards.”<br>“Bottle-MySQL是一个能够将你的应用和MySQL整合起来的插件。它在请求开始的时自动地连接上数据库，通过数据库句柄到路由回调，最后关闭连接。”</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import bottle</span><br><span class="line">import bottle_mysql</span><br><span class="line"></span><br><span class="line">app = bottle.Bottle()</span><br><span class="line">plugin = bottle_mysql.Plugin(<span class="attribute">dbuser</span>=<span class="string">'user'</span>, <span class="attribute">dbpass</span>=<span class="string">'pass'</span>, <span class="attribute">dbname</span>=<span class="string">'db'</span>)</span><br><span class="line">app.install(plugin)</span><br></pre></td></tr></table></figure>
<p>你也可以直接用python的数据库模块MYSQLdb来连接MYSQL，直接import MYSQLdb就可以。</p>
<p><strong> Bottle-SQLite </strong></p>
<p>这个插件让在Bottle应用中使用sqlite数据库变得简单。你只要在route的回调函数里添加一个‘db’参数，就能使用数据库链接了。</p>
<pre><code>$ pip install bottle-sqlite
</code></pre><h2 id="API编写与参考"><a href="#API编写与参考" class="headerlink" title="API编写与参考"></a>API编写与参考</h2><p>也是跟flask差不多，不同的是它可以把HTTP请求方法作装饰器用.</p>
<p>一个简单的栗子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bottle <span class="keyword">import</span> request, response</span><br><span class="line"><span class="keyword">from</span> bottle <span class="keyword">import</span> post, get, put, delete</span><br><span class="line"></span><br><span class="line">_names = set()           <span class="comment"># the set of names</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@post('/names')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">creation_handler</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="string">'''Handles name creation'''</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@get('/names')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">listing_handler</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="string">'''Handles name listing'''</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@put('/names/&lt;name&gt;')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_handler</span><span class="params">(name)</span>:</span></span><br><span class="line">	<span class="string">'''Handles name updates'''</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@delete('/names/&lt;name&gt;')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete_handler</span><span class="params">(name)</span>:</span></span><br><span class="line">	<span class="string">'''Handles name deletions'''</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>也可以单独创建一个API文档，将上面这段代码保存为names.py，然后再建立一个main.py文件。</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">import</span> bottle</span><br><span class="line">from api <span class="built_in">import</span> names</span><br><span class="line"></span><br><span class="line"><span class="attr">app</span> = <span class="attr">application</span> = bottle.default_app()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="attr">__name__</span> == '__main__':</span><br><span class="line">	bottle.run(<span class="attr">host</span> = '<span class="number">127.0</span>.<span class="number">0.1</span>', <span class="attr">port</span> = <span class="number">8000</span>)</span><br></pre></td></tr></table></figure>
<p><strong>参考</strong>：<br><a href="http://wenku.baidu.com/link?url=AXvHmcyWezZ7MK0RTN89X4QGP91IN-Nyl1cD1V94QeCdFu5k9AqzwjPzi_4CDSCY3arrp-RtYtSyH6FBOXYuvuPIrh6QQNan4F8-N2jCoAa" target="_blank" rel="noopener">API参考</a><br><a href="http://www.bottlepy.org/docs/dev/api.html" target="_blank" rel="noopener">API Reference</a></p>
<h2 id="项目部署"><a href="#项目部署" class="headerlink" title="项目部署"></a>项目部署</h2><p>Bottle默认运行在它内置的随python一起发布的WSGI reference Server服务器上。这个单线程的HTTP服务器在开发时很有用，但是性能较低.<br>最简单的增加性能的办法是安装一个多线程的服务器库，例如paste或者cherrypy ，并告诉 Bottle 使用它来替代单线程的服务器:</p>
<pre><code>bottle.run(server=&apos;paste&apos;)
</code></pre><p>默认地，Bottle会监听127.0.1的8080端口，如果想更改它，就更改run函数的参数。当Bottle运行在其他服务器上时，port和host参数依然适用。</p>
<pre><code>run(port=80,host=&apos;123.45.67.89&apos;)
</code></pre><p>因为这个服务器是单线程的，一次只能响应一个请求，可是Bottle已经可以工作在很多多线程的服务器上了，所以还是建议在大型项目上使用高性能服务器。</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Bottle v0<span class="meta">.12</span><span class="meta">.9</span> server starting <span class="meta">up</span> (using WSGIRefServer())...</span><br><span class="line">Listening on http://<span class="number">127.0</span><span class="meta">.0</span><span class="meta">.1</span>:<span class="number">8080</span>/</span><br><span class="line">Hit Ctrl-C to quit.</span><br></pre></td></tr></table></figure>
<h2 id="其他特性（待加入）"><a href="#其他特性（待加入）" class="headerlink" title="其他特性（待加入）"></a>其他特性（待加入）</h2><h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><p>Bottle自身没有提供Session(处理用户在多次请求之间需要存储的数据)的支持，但可以使用<a href="http://beaker.readthedocs.org/en/latest/" target="_blank" rel="noopener">beaker</a>中间件来实现。<br>Beaker是一个缓存和会话的库，与Web应用程序和独立的Python脚本及应用程序一起使用。它是WSGI的中间件，能够很简单地嵌入，与基于WSGI的Web应用程序一起使用，并且缓存修饰器对于任何基于Python的应用程序都是容易使用的。</p>
<pre><code>$ pip install beaker
</code></pre><p>栗子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bottle <span class="keyword">import</span> route, run ,redirect,request,default_app</span><br><span class="line"><span class="keyword">from</span> beaker.middleware <span class="keyword">import</span> SessionMiddleware</span><br><span class="line"><span class="comment">#设置session参数（Session数据存放在'/tmp/'目录里面，/tmp/有个机制，会自动清理30天后末使用过的文件，有点类型于回收站，所以你不需要担心session文件不断增多的问题。）</span></span><br><span class="line">session_opts = &#123;</span><br><span class="line">	<span class="string">'session.type'</span>:<span class="string">'file'</span>,                   <span class="comment"># 以文件的方式保存session</span></span><br><span class="line">	<span class="string">'session.cookei_expires'</span>:<span class="number">3600</span>,       <span class="comment"># session过期时间为3600秒</span></span><br><span class="line">	<span class="string">'session.data_dir'</span>:<span class="string">'/tmp/sessions'</span>,  <span class="comment"># session存放路径</span></span><br><span class="line">	<span class="string">'sessioni.auto'</span>:<span class="literal">True</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">app = SessionMiddleware(bottle.app(), session_opts)</span><br><span class="line"></span><br><span class="line"><span class="meta">@bottle.route('/test')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">	s = bottle.request.environ.get(<span class="string">'beaker.session'</span>) <span class="comment">#获取session,则获取环境变量中的beaker.session对象，并赋值给s，然后我们就可以用字典的方式，往s里面添加一些我们要存进去的数据，如帐号名，帐号id，权限等等</span></span><br><span class="line">	s[<span class="string">'test'</span>] = s.get(<span class="string">'test'</span>, <span class="number">0</span>)+<span class="number">1</span>   <span class="comment">#从session中获取Key为test的值</span></span><br><span class="line">	s.save()</span><br><span class="line">	<span class="keyword">return</span> <span class="string">'Test counter: %d'</span> % s[<span class="string">'test'</span>]</span><br><span class="line">			</span><br><span class="line">bottle.run(app=app,host=<span class="string">'0.0.0.0'</span>, port=<span class="number">8080</span>,debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<h3 id="一些推荐的可用的插件"><a href="#一些推荐的可用的插件" class="headerlink" title="一些推荐的可用的插件"></a>一些推荐的可用的插件</h3><blockquote>
<p>Bottle-Beaker:Beaker to session and caching library with WSGI Middleware<br>Bottle-Cork:Cork provides a simple set of methods to implement Authentication and Authorization in web applications based on Bottle.<br>Bottle-Extras:Meta package to install the bottle plugin collection.<br>Bottle-Flash:flash plugin for bottle<br>Bottle-Hotqueue:FIFO Queue for Bottle built upon redis<br>Macaron:Macaron is an object-relational mapper (ORM) for SQLite.<br>Bottle-Memcache:Memcache integration for Bottle.<br>Bottle-Mongo:MongoDB integration for Bottle<br>Bottle-Redis:Redis integration for Bottle.<br>Bottle-Renderer:Renderer plugin for bottle<br>Bottle-ServefilesA reusable app that serves static files for bottle apps<br>Bottle-Sqlalchemy:SQLAlchemy integration for Bottle.<br>Bottle-Sqlite:SQLite3 database integration for Bottle.<br>Bottle-Web2pydal:Web2py Dal integration for Bottle.<br>Bottle-Werkzeug:Integrates the werkzeug library (alternative request and response objects, advanced debugging middleware and more)</p>
</blockquote>
<h2 id="Bottle学习资源"><a href="#Bottle学习资源" class="headerlink" title="Bottle学习资源"></a>Bottle学习资源</h2><ul>
<li>PS：因为Bottle真的太小了，以至于网上关于它的资料也比较少，而且基本上都是差不多的，感觉官方文档也不是很全面，相关的书也没有，于是只能大量百度和google来搜集资料学习。</li>
</ul>
<p><a href="http://www.bottlepy.org/docs/dev/" target="_blank" rel="noopener">Bottle: Python Web Framework</a><br><a href="http://download.csdn.net/detail/cuihairu/8333909" target="_blank" rel="noopener">Bottle v0.11中文文档</a><br><a href="http://www.jb51.net/article/63736.htm" target="_blank" rel="noopener">简单介绍Python的轻便web框架Bottle</a><br><a href="https://www.linuxyw.com/category/bottle" target="_blank" rel="noopener">bottle框架基础教程</a><br><a href="http://www.maiziedu.com/course/python/494-6414/" target="_blank" rel="noopener">Bottle web 开发 （视频）</a><br><a href="http://ju.outofmemory.cn/entry/220152" target="_blank" rel="noopener">几个bottle插件</a><br><a href="https://pypi.python.org/pypi/bottle-mysql/0.1.4" target="_blank" rel="noopener">bottle-mysql 0.1.4</a><br><a href="http://www.devstore.cn/essay/essayInfo/5446.html" target="_blank" rel="noopener">Python Web框架</a><br><a href="http://www.jianshu.com/p/f796428ceaae" target="_blank" rel="noopener">Bottle手册(0.13-dev)中文翻译</a><br><a href="http://cizixs.com/2016/01/20/dive-into-bottle" target="_blank" rel="noopener">bottle 源码解析</a><br><a href="http://rwpy4l.readthedocs.org/en/latest/ch05/TryBottle.html" target="_blank" rel="noopener">初窥Bottle</a><br><a href="http://www.lovedata.cn/ec/Python/2015/1204/7161.html" target="_blank" rel="noopener">Python程序员都会喜欢的6个库</a><br><a href="http://www.lovedata.cn/ec/Python/2015/1204/7161.html" target="_blank" rel="noopener">bottle中文</a><br><a href="http://chenpeng.info/html/2155" target="_blank" rel="noopener">微型Python Web框架 Bottl</a><br><a href="http://blog.csdn.net/happyteafriends/article/details/42552093" target="_blank" rel="noopener">bottle中文教程</a><br><a href="http://www.zgxue.com/169/1698482.html" target="_blank" rel="noopener">Python的Bottle框架的一些使用技巧介绍</a><br><a href="http://www.bubuko.com/infodetail-1114779.html" target="_blank" rel="noopener">Bottle框架常见的几个坑</a><br><a href="http://wenku.baidu.com/link?url=AXvHmcyWezZ7MK0RTN89X4QGP91IN-Nyl1cD1V94QeCdFu5k9AqzwjPzi_4CDSCY3arrp-RtYtSyH6FBOXYuvuPIrh6QQNan4F8-N2jCoAa" target="_blank" rel="noopener">Bottle API 参考 中文</a><br><a href="http://www.avelino.xxx/2015/02/where-to-start-a-project-with-bottle-boilerplate#toc_0" target="_blank" rel="noopener">Where to start a project with bottle, Boilerplate</a><br><a href="http://blog.sina.com.cn/s/blog_8d0ab46b0102whrd.html" target="_blank" rel="noopener">Python3 bottle Web开发系列教程</a><br><a href="https://www.toptal.com/bottle/building-a-rest-api-with-bottle-framework" target="_blank" rel="noopener">Building a Rest API with the Bottle Framework</a><br><a href="https://realpython.com/blog/python/developing-with-bottle-part-1/" target="_blank" rel="noopener">Developing With Bottle</a><br><a href="http://article.yeeyan.org/view/35282/126927" target="_blank" rel="noopener">Bottle API 参考</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;“Bottle是一个快速，简单，轻量级的Python WSGI Web框架。它小巧但高效，整个框架只有一个文件，却
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>python 函数的参数</title>
    <link href="http://yoursite.com/2016/03/16/python-%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0/"/>
    <id>http://yoursite.com/2016/03/16/python-函数的参数/</id>
    <published>2016-03-16T15:22:27.000Z</published>
    <updated>2016-04-27T13:20:29.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>因为一直不是很理解函数的参数，然后复习的时候就总结了一下，免得以后又忘记…</strong></p>
<h2 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h2><p><strong>调用函数时，传入函数的参数的位置（顺序）一一对应着定义函数时参数的位置，且传入函数的参数与函数声明时的参数数目必须一致,不然会报错。看看栗子：</strong></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt;<span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x,y,z)</span></span><span class="symbol">:</span></span><br><span class="line">...    <span class="keyword">return</span> x,y,z</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;print f(x,y,z)</span><br><span class="line">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;<span class="function"><span class="keyword">def</span> <span class="title">g</span><span class="params">(x,y,z)</span></span><span class="symbol">:</span></span><br><span class="line">...    <span class="keyword">return</span> x,z,y</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;print g(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">(<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p><strong>第二个函数中，先返回z，再返回y。因为声明函数时参数名的位置，与调用时所传参数位置是相对应的，所以其实在两个函数中，都是x=1，y=2，z=3，而输出的结果是由return的顺序来决定的。</strong></p>
<h2 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h2><p><strong>关键字参数其实就是给参数起一个名字。调用函数的时候就是通过参数的名字来区分参数，而不是它们的位置、顺序。于是，调用函数时，参数的数目和顺序都不一定要对应定义函数时的参数数目和顺序（即允许参数缺失和不按顺序）。</strong></p>
<ul>
<li>首先你可以直接按照函数声明中参数定义的顺序来调用它（这样看起来就跟位置函数没什么区别了..）：</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt;<span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(name,age)</span></span><span class="symbol">:</span></span><br><span class="line">...    <span class="keyword">return</span> <span class="string">'%s is %s years old.'</span> % (name,age)</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;print f(<span class="string">'Rose'</span>,<span class="string">'eighteen'</span>)</span><br><span class="line">Rose is eighteen years old.</span><br></pre></td></tr></table></figure>
<ul>
<li>再来看看如何不按顺序地调用它（这样就稍微看出来一点区别了..）：**</li>
</ul>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="builtin-name">print</span> f(<span class="attribute">age</span>=<span class="string">'eighteen'</span>,name='Rose')</span><br><span class="line">Rose is eighteen years old.</span><br></pre></td></tr></table></figure>
<ul>
<li>然后来看看如何数目不对应地调用它：</li>
</ul>
<p><strong>关键字参数可以在定义函数时设置关键字参数默认值，也就是默认参数。上面提到过允许参数缺失，这个就是和默认参数有关了。</strong><br><strong>默认参数就是，在函数声明中就给参数提供一个值。这样在调用函数时，如果没有为参数传递一个值，那么这个参数就会取默认值。</strong></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt;<span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(name=<span class="string">'Rose'</span>,age=<span class="string">'eighteen'</span>)</span></span></span><br><span class="line">...    <span class="keyword">return</span> <span class="string">'%s is %s years old.'</span> % (name,age)</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;print f()</span><br><span class="line">Rose is eighteen years old.</span><br></pre></td></tr></table></figure>
<p><strong>你也可以在调用函数时传入新参数：</strong></p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="built_in">print</span> f(<span class="string">'Jack'</span>)</span><br><span class="line">Jack <span class="keyword">is</span> eighteen years old.</span><br><span class="line">&gt;&gt;&gt;<span class="built_in">print</span> f(<span class="string">'Jack'</span>,<span class="string">'nineteen'</span>)</span><br><span class="line">Jack <span class="keyword">is</span> nineteen years old.</span><br></pre></td></tr></table></figure>
<p><strong>可是如果想name使用默认参数，而age传入新参数该怎么办？别忘了它可是关键字参数！（虽然上面这个例子按顺序传入参数让它看起来就像位置参数..）</strong><br><strong>所以可以这样：</strong></p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="builtin-name">print</span> f(<span class="attribute">age</span>=<span class="string">'nineteen'</span>)</span><br><span class="line">   Rose is nineteen years old.</span><br></pre></td></tr></table></figure>
<p><strong>注意：声明函数时，所有的位置参数都必须出现在任何一个默认参数前面。否则会报错。而且在调用函数的时候，一定要给位置参数提供值。</strong></p>
<h2 id="可变长度的参数"><a href="#可变长度的参数" class="headerlink" title="可变长度的参数"></a>可变长度的参数</h2><p><strong>调用函数时，有时候可能会需要处理可变数量的参数。这种参数在函数声明中不是显式命名的，因为在调用函数之前，参数的数目是未知的。于是我们可以将参数放在一个元组（非关键字参数）或字典中（关键字参数），作为一个参数组传递给函数。</strong></p>
<h3 id="非关键字可变长参数（元组）"><a href="#非关键字可变长参数（元组）" class="headerlink" title="非关键字可变长参数（元组）"></a>非关键字可变长参数（元组）</h3><p><strong>当函数被调用时，所有的形参（位置参数和默认参数）都将值赋给了在函数声明时相对应的部分参数，然后剩下那部分非关键字参数就会按顺序插入到一个元组。这个元组是以一个*号开头的。</strong><br><strong>*号操作符后的形参会作为元组传递给函数，元组保存了调用函数时所有传递给函数的“额外”的参数（匹配了所有位置参数和关键字参数剩余的）。而如果没有额外的参数，这个元组就为空元祖。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x,*args)</span>:</span></span><br><span class="line"><span class="meta">... </span>	<span class="keyword">print</span> x</span><br><span class="line"><span class="meta">... </span>	<span class="keyword">print</span> args</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(a)</span><br><span class="line"><span class="number">1</span></span><br><span class="line">()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(<span class="number">1</span>,<span class="number">2</span>,<span class="string">'a'</span>,<span class="string">'b'</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line">(<span class="number">2</span>,<span class="string">'a'</span>,<span class="string">'b'</span>)</span><br></pre></td></tr></table></figure>
<p><strong>第一个位置参数被赋了1的值，剩下的参数全部保存在*args这个元组里。于是我们就可以处理当超出数目的参数被传入函数的情形。</strong></p>
<ul>
<li>注意：所有形式参数必须放在非关键字可变长参数的前面。</li>
<li>先来举个栗子：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x,y=<span class="string">'1'</span>,*args)</span>:</span></span><br><span class="line">	<span class="keyword">print</span> <span class="string">'x:'</span>, x</span><br><span class="line">	<span class="keyword">print</span> <span class="string">'y:'</span>, y</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> args:    <span class="comment">#遍历元组中参数</span></span><br><span class="line">		<span class="keyword">print</span> <span class="string">'args:'</span>, i</span><br></pre></td></tr></table></figure>
<p><strong>好，调用这个函数试试看。</strong></p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="selector-tag">f</span>(<span class="string">'abc'</span>)</span><br><span class="line"><span class="selector-tag">x</span><span class="selector-pseudo">:abc</span></span><br><span class="line"><span class="selector-tag">y</span><span class="selector-pseudo">:1</span></span><br><span class="line">&gt;&gt;&gt; <span class="selector-tag">f</span>(<span class="number">11</span>,<span class="number">22</span>)</span><br><span class="line"><span class="selector-tag">x</span><span class="selector-pseudo">:11</span></span><br><span class="line"><span class="selector-tag">y</span><span class="selector-pseudo">:22</span></span><br><span class="line">&gt;&gt;&gt; <span class="selector-tag">f</span>(<span class="number">123</span>,<span class="string">'abc'</span>,<span class="string">'xyz'</span>,<span class="number">456</span>)</span><br><span class="line"><span class="selector-tag">x</span><span class="selector-pseudo">:123</span></span><br><span class="line"><span class="selector-tag">y</span><span class="selector-pseudo">:abc</span></span><br><span class="line"><span class="selector-tag">args</span><span class="selector-pseudo">:xyz</span></span><br><span class="line"><span class="selector-tag">args</span><span class="selector-pseudo">:456</span></span><br></pre></td></tr></table></figure>
<h3 id="关键字变量参数（字典）"><a href="#关键字变量参数（字典）" class="headerlink" title="关键字变量参数（字典）"></a>关键字变量参数（字典）</h3><p><strong>它就是保存“额外”的关键字参数的字典，这个字典以**开头。其参数名是字典的键。（关键字参数有着参数名和参数值，所以元组没法满足它，于是要用字典。）</strong></p>
<ul>
<li>栗子：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x,y,*args,**kwargs)</span>:</span></span><br><span class="line">	<span class="keyword">print</span> <span class="string">'x:'</span>, x</span><br><span class="line">	<span class="keyword">print</span> <span class="string">'y:'</span>, y</span><br><span class="line">	<span class="keyword">for</span> m <span class="keyword">in</span> args:</span><br><span class="line">		<span class="keyword">print</span> <span class="string">'non-keyword arg:'</span>, m</span><br><span class="line">	<span class="keyword">for</span> n <span class="keyword">in</span> kwargs.keys():         <span class="comment">#遍历字典的键，因为参数名是字典的键</span></span><br><span class="line">		<span class="keyword">print</span> <span class="string">"keyword arg '%s': %s"</span> % (n,kwargs[n])</span><br></pre></td></tr></table></figure>
<p><strong>好，来调用它。</strong></p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;f(<span class="number">1</span>,<span class="number">2</span>,<span class="string">'abc'</span>,<span class="string">'xyz'</span>,q=<span class="number">123</span>,w=<span class="number">456</span>)</span><br><span class="line">x:<span class="number">1</span></span><br><span class="line">y:<span class="number">2</span></span><br><span class="line">non-keyword <span class="keyword">arg</span>:abc</span><br><span class="line">non-keyword <span class="keyword">arg</span>:xyz</span><br><span class="line">keyword <span class="keyword">arg</span> <span class="string">'q'</span>:<span class="number">123</span></span><br><span class="line">keyword <span class="keyword">arg</span> <span class="string">'w'</span>:<span class="number">456</span></span><br></pre></td></tr></table></figure>
<p><strong>还可以这样调用：</strong>    </p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;f(<span class="number">1</span>,<span class="number">2</span>,*(<span class="number">3</span>,<span class="number">4</span>),**&#123;<span class="string">'a'</span>:<span class="number">5</span>,<span class="string">'b'</span>:<span class="number">6</span>&#125;)</span><br><span class="line">x:<span class="number">1</span></span><br><span class="line">y:<span class="number">2</span></span><br><span class="line">non-keyword <span class="keyword">arg</span>:<span class="number">3</span></span><br><span class="line">non-keyword <span class="keyword">arg</span>:<span class="number">4</span></span><br><span class="line">keyword <span class="keyword">arg</span> <span class="string">'a'</span>:<span class="number">5</span></span><br><span class="line">keyword <span class="keyword">arg</span> <span class="string">'b'</span>:<span class="number">6</span></span><br></pre></td></tr></table></figure>
<p><strong>还有这样：</strong></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; tuple = (<span class="number">6</span>,<span class="number">7</span>)</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; dict = &#123;<span class="string">'a'</span><span class="symbol">:</span><span class="number">8</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; f(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,b=<span class="number">4</span>,*tuple,**dict)</span><br><span class="line"><span class="symbol">x:</span><span class="number">1</span></span><br><span class="line"><span class="symbol">y:</span><span class="number">2</span></span><br><span class="line">non-keyword <span class="symbol">arg:</span><span class="number">3</span></span><br><span class="line">non-keyword <span class="symbol">arg:</span><span class="number">6</span></span><br><span class="line">non-keyword <span class="symbol">arg:</span><span class="number">7</span></span><br><span class="line">keyword arg <span class="string">'a'</span><span class="symbol">:</span><span class="number">8</span></span><br><span class="line">keyword arg <span class="string">'b'</span><span class="symbol">:</span><span class="number">4</span></span><br></pre></td></tr></table></figure>
<p><strong>这里很奇怪的是，调用函数时，对于元组，先将3传入并返回，然后再将元组里的元素作为参数传入并返回；而对于字典，顺序刚好相反，这是为什么呢？不知道..没想出来..</strong></p>
<ul>
<li>注意：关键字参数应为函数定义的最后一个参数。</li>
</ul>
<p><strong>所以这些参数的定义顺序为：位置参数，关键字参数，非关键字可变长参数，关键字变量参数。</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;因为一直不是很理解函数的参数，然后复习的时候就总结了一下，免得以后又忘记…&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;位置参数&quot;&gt;&lt;a href=&quot;#位置参数&quot; class=&quot;headerlink&quot; title=&quot;位置参数&quot;&gt;&lt;/a&gt;位置参数&lt;/h2&gt;&lt;p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>RESTful API 小结</title>
    <link href="http://yoursite.com/2016/02/24/RESTful-API%E5%B0%8F%E7%BB%93/"/>
    <id>http://yoursite.com/2016/02/24/RESTful-API小结/</id>
    <published>2016-02-24T14:55:43.000Z</published>
    <updated>2016-02-24T15:21:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="REST（Representational-State-Transfer）"><a href="#REST（Representational-State-Transfer）" class="headerlink" title="REST（Representational State Transfer）"></a>REST（Representational State Transfer）</h1><p><strong>REST全称Representational State Transfer，译为“表现层状态转化”，REST指的是一组架构约束条件和原则。满足这些约束条件和原则的应用程序或设计就是 RESTful。</strong></p>
<h3 id="1-表现层-Representation"><a href="#1-表现层-Representation" class="headerlink" title="1.表现层 Representation"></a>1.表现层 Representation</h3><p><strong>“表现层”实际指的是“资源”的“表现层”。</strong></p>
<ul>
<li>“资源”，就是网络上一个实体或者说一个具体信息，例如一段文本、一张图片、一首歌等，每种“资源”用一个特定的URI指向，因此URI就成了每一个资源的地址或独一无二的识别符，获取这个资源，访问它的URI就可以。（”上网”，就是调用互联网上的资源的URI。）</li>
<li>“表现层”就是“资源”呈现出来的形式。比如，文本可以用txt格式表现，也可以用HTML格式、XML格式等表示。URI只代表”资源”的位置。它的具体表现形式即表现层，应该在HTTP请求的头信息中用Accept和Content-Type字段指定。</li>
</ul>
<h3 id="2-状态转化-State-Transfer"><a href="#2-状态转化-State-Transfer" class="headerlink" title="2.状态转化 State Transfer"></a>2.状态转化 State Transfer</h3><p>客户端和服务器的互动过程中，涉及到数据和状态的变化。HTTP协议，是一个无状态协议。所以，所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，对服务器端资源进行操作，必须通过某种手段，让服务器端发生”状态转化”。这种转化建立在表现层之上，所以就是”表现层状态转化”。</p>
<ul>
<li>客户端用到的手段，就是HTTP协议里的方法：<blockquote>
<p>GET：获取一个资源或者一个集合的所有资源<br>POST：在服务器上新建资源<br>PUT：更新服务器上的资源(提供整个修改后的资源)<br>PATCH：更新服务器上的资源(只提供需要修改的部分)<br>DELETE：从服务器上删除一个资源<br>HEAD：获取资源的元信息(结构)<br>OPTIONS：获取使用者可以对资源进行的操作</p>
</blockquote>
</li>
</ul>
<p><strong>总的来说，就是，客户端使用HTTP协议的几种方法，让服务器端的资源的表现层发生“状态转化”。</strong></p>
<h3 id="3-REST特征"><a href="#3-REST特征" class="headerlink" title="3.REST特征"></a>3.REST特征</h3><ul>
<li>采用客户端/服务器模式</li>
<li>所有必要的信息要在客户端发出的请求中。服务器不能在两次请求之间保存客户端的任何状态。</li>
<li>服务器发出的响应可以标记为可缓存或不可缓存，出于优化目的，客户端可以使用缓存。</li>
<li>客户端访问服务器资源时使用的协议必须一致。</li>
<li>客户端和服务器之间可按需插入代理服务器、缓存或网关。</li>
<li>客户端可从服务器上下载代码，在客户端的环境中执行。</li>
</ul>
<h3 id="4-REST四个基本原则："><a href="#4-REST四个基本原则：" class="headerlink" title="4.REST四个基本原则："></a>4.REST四个基本原则：</h3><ul>
<li>使用HTTP动词。</li>
<li>无状态连接，服务器端不应保存过多上下文状态，即每个请求都是独立的。</li>
<li>为每个资源设置URI。</li>
<li><p>通过XML JSON进行数据传递。</p>
<hr>
</li>
</ul>
<h1 id="API-应用程序接口-API-Application-Program-Interface"><a href="#API-应用程序接口-API-Application-Program-Interface" class="headerlink" title="API:应用程序接口(API:Application Program Interface)"></a>API:应用程序接口(API:Application Program Interface)</h1><p><strong>API的实质是一些封装好的函数，它是操作系统提供给应用程序的一个调用接口，调用这个接口能使操作系统去执行应用程序的命令（动作）。可以说它是软件制定的功能访问接口.</strong><br>（例如你自己写了一个类，这个类里有很多函数，如果用户要使用你这个类，但是只知道这个函数的入口参数和返回值即只知道这个函数是做什么用的，对于用户来说你这些函数就是API。）</p>
<h3 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h3><ul>
<li>提供应用程序与开发人员基于某软件或硬件的以访问一组例程的能力。</li>
<li>简化程序员对系统内部的调用。</li>
<li>实现不同系统之间数据交换。</li>
<li>实现计算机软件之间的相互通信。</li>
<li>API的一个主要功能是提供通用功能集。程序员通过调用API函数对应用程序进行开发，可以减轻编程任务。</li>
</ul>
<h3 id="API-设计："><a href="#API-设计：" class="headerlink" title="API 设计："></a>API 设计：</h3><ul>
<li>在系统中是最外层的接口，是供用户直接调用的。</li>
<li>稳定。</li>
<li>定义清楚：方法名应该一目了然，参数数据结构良好，文档丰富清晰。</li>
<li>多形式：可以用java进行export，以库的形式提供，也可以通过REST的方式进行访问等等。</li>
</ul>
<h3 id="API的四种类型"><a href="#API的四种类型" class="headerlink" title="API的四种类型:"></a>API的四种类型:</h3><ul>
<li>远程过程调用(RPC):通过作用在共享数据缓存器上的过程(或任务)实现程序间的通信。</li>
<li>标准查询语言(SQL):是标准的访问数据的查询语言，通过数据库实现应用程序间的数据共享。</li>
<li>文件传输:文件传输通过发送格式化文件实现应用程序间数据共享。</li>
<li>信息交付:指松耦合或紧耦合应用程序间的小型格式化信息，通过程序间的直接通信实现数据共享。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;REST（Representational-State-Transfer）&quot;&gt;&lt;a href=&quot;#REST（Representational-State-Transfer）&quot; class=&quot;headerlink&quot; title=&quot;REST（Representatio
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>python 魔法方法</title>
    <link href="http://yoursite.com/2015/12/09/python-%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2015/12/09/python-魔法方法/</id>
    <published>2015-12-08T16:08:12.000Z</published>
    <updated>2016-04-27T13:23:32.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>魔法方法即前后各加两个下划线的名字组成的集合所包含的方法。（如果对象实现了魔法方法中的某一个，那么这个方法会在特殊的情况下被调用） </strong></p>
<hr>
<hr>
<h3 id="一、为确保类是新型的，模块最开始要输入赋值语句-metaclass-type，或者直接或间接地子类化内建类object（或其他一些新式类）。"><a href="#一、为确保类是新型的，模块最开始要输入赋值语句-metaclass-type，或者直接或间接地子类化内建类object（或其他一些新式类）。" class="headerlink" title="一、为确保类是新型的，模块最开始要输入赋值语句__metaclass__=type，或者直接或间接地子类化内建类object（或其他一些新式类）。"></a>一、为确保类是新型的，模块最开始要输入赋值语句__metaclass__=type，或者直接或间接地子类化内建类object（或其他一些新式类）。</h3><hr>
<h3 id="二、构造和初始化"><a href="#二、构造和初始化" class="headerlink" title="二、构造和初始化"></a>二、构造和初始化</h3><blockquote>
<p>1.__new__(cls,…):一个对象实例化的时候所调用的第一个方法，它的第一个参数是这个类，其他的参数是用来直接传递给__init__ 方法。<br>2.__init__(self,…):(最基本的魔术方法)<br>这是类的初始化方法，当构造函数被调用的时候的任何参数都将会传给它。<br>3.__del__(self):它定义的是当一个对象进行垃圾回收时候的行为。<br>  当调用 x = SomeClass() 的时候,__init__ 并不是第一个被调用的方法。是__new__来构造这个实例。\</p>
</blockquote>
<hr>
<h3 id="三、用于比较的魔术方法"><a href="#三、用于比较的魔术方法" class="headerlink" title="三、用于比较的魔术方法"></a>三、用于比较的魔术方法</h3><blockquote>
<p>1.__cmp__：最基本的用于比较的魔术方法。它实际上实现了所有的比较符号(&lt;,==,!=,等等)<br>2.__eq__(self, other)：等号, ==<br>3.__ne__(self, other)：不等号, !=<br>4.__lt__(self, other)：小于号,  &lt;<br>5.__gt__(self, other)：大于等于号,&gt;= \</p>
</blockquote>
<hr>
<h3 id="四、数值处理的魔术方法"><a href="#四、数值处理的魔术方法" class="headerlink" title="四、数值处理的魔术方法"></a>四、数值处理的魔术方法</h3><p>一元操作符和函数：仅仅有一个操作位的一元操作符和函数</p>
<blockquote>
<p>__pos__(self)：正号<br>__neg__(self)：负号<br>__abs__(self)：实现内置abs()函数的行为<br>__invert__(self) ：~ 符号\</p>
</blockquote>
<hr>
<h3 id="五、普通算数操作符"><a href="#五、普通算数操作符" class="headerlink" title="五、普通算数操作符"></a>五、普通算数操作符</h3><blockquote>
<p>__add__(self, other)：加法<br>__sub__(self, other)：减法<br>__mul__(self, other)：乘法<br>__floordiv__(self, other)：地板除法，使用//操作符<br>__div__(self, other)：传统除法，使用/操作符<br>__truediv__(self, other)：真正除法。注意，只有当from __future__ import division时才会有效<br>__mod__(self, other)：求模，使用%操作符<br>__divmod__(self, other)：实现内建函数divmod()的行为<br>__pow__(self, other)：乘方，使用**操作符<br>__lshift__(self, other)：左按位位移，使用&lt;&lt;操作符<br>__rshift__(self, other)：右按位位移，使用&gt;&gt;操作符<br>__and__(self, other)：按位与，使用&amp;操作符<br>__or__(self, other)：按位或，使用|操作符<br>__xor__(self, other)：按位异或，使用^操作符\</p>
</blockquote>
<hr>
<h3 id="六、反射算术操作符"><a href="#六、反射算术操作符" class="headerlink" title="六、反射算术操作符"></a>六、反射算术操作符</h3><p>改变操作数的位置关系，大多数情况下，反射算术操作的结果等价于常规算术操作</p>
<blockquote>
<p>__radd__(self, other)：反射加法<br>__rsub__(self, other)：反射减法<br>__rmul__(self, other)：反射乘法<br>__rfloordiv__(self, other)：反射地板除，用//操作符<br>__rdiv__(self, other)：传统除法，用/操作符<br>__rturediv__(self, other)：真实除法，注意，只有当from __future__ import division时才会有效<br>__rmod__(self, other)：反射求模，用%操作符<br>__rdivmod__(self,other)：实现内置函数divmod()的长除行为，当调用divmod(other,self)时被调用<br>__rpow__(self, other)：反射乘方，用**操作符<br>__rlshift__(self, other)：反射的左按位位移，使用&lt;&lt;操作符<br>__rrshift__(self, other)：反射的右按位位移，使用&gt;&gt;操作符<br>__rand__(self, other)：反射的按位与，使用&amp;操作符<br>__ror__(self, other)：反射的按位或，使用|操作符<br>__rxor__(self, other)：反射的按位异或，使用^操作符\</p>
</blockquote>
<hr>
<h3 id="七、增量赋值"><a href="#七、增量赋值" class="headerlink" title="七、增量赋值"></a>七、增量赋值</h3><blockquote>
<p>__iadd__(self, other)：加法和赋值<br>__isub__(self, other)：减法和赋值<br>__imul__(self, other)：乘法和赋值<br>__ifloordiv__(self, other)：地板除和赋值，用//=操作符<br>__idiv__(self, other)：传统除法和赋值，用/=操作符<br>__iturediv__(self, other)：真实除法和赋值，注意，只有当from __future__ import division时才会有效<br>__imod__(self, other)：求模和赋值，用%=操作符<br>__ipow__(self, other)：乘方和赋值，用**=操作符<br>__ilshift__(self, other)：左按位位移和赋值，使用&lt;&lt;=操作符<br>__irshift__(self, other)：右按位位移和赋值，使用&gt;&gt;=操作符<br>__iand__(self, other)：按位与和赋值，使用&amp;=操作符<br>__ior__(self, other)：按位或和赋值，使用|=操作符<br>__ixor__(self, other)：按位异或和赋值，使用^=操作符\</p>
</blockquote>
<hr>
<h3 id="八、类型转换"><a href="#八、类型转换" class="headerlink" title="八、类型转换"></a>八、类型转换</h3><blockquote>
<p>__int__(self)：实现到整型的类型转换<br>__long__(self)：长整形<br>__float__(self)：浮点型<br>__complex__(self)：复数型<br>__oct__(self)：8进制型<br>__hex__(self)：16进制型<br>__index__(self)：实现一个当对象被切片到int的类型转换。若自定义了一个数值类型，考虑到它可能被切片，要重载__index__<br>__trunc__(self)：当math.trunc(self)被调用时调用。返回一个整型的截断<br>__coerce__(self,other)：实现混合模式的算术。如果类型转换不可能则返回None。否则，它应当返回一对相同类型的元祖\</p>
</blockquote>
<hr>
<h3 id="九、描述类"><a href="#九、描述类" class="headerlink" title="九、描述类"></a>九、描述类</h3><p><strong>在类中自定义内建函数返回类行为的描述</strong></p>
<blockquote>
<p>__str__(self)：定义行为<br>__repr__(self)：定义行为。<br><strong>str()和repr()主要的区别在于它的阅读对象。repr()产生的输出主要为计算机可读，而str()则是为了让人类可读。</strong><br>__unicode__(self)：定义行为。<br><strong>unicode()像是str(),但它返回一个unicode字符串。如果你的类中的一个实例调用了str(),而你仅定义了__unicode__(),那它是不会工作的。以防万一，你应当总是定义好 __str__()，哪怕用户不会使用unicode</strong><br>__hash__(self)：定义行为。它必须返回一个整型，而且它的结果是用于来在字典中作为快速键比对。<br>__nonzero__(self)：定义行为。返回True或False，取决于你是否考虑一个实例是True或False。</p>
</blockquote>
<hr>
<h3 id="十、属性访问控制"><a href="#十、属性访问控制" class="headerlink" title="十、属性访问控制"></a>十、属性访问控制</h3><blockquote>
<p>__getattr__(self, name)：用户在试图访问不存在（不论是存在或尚未建立）的类属性时定义其行为<br>__setattr__(self, name, value)：允许你为一个属性赋值<br>__delattr__：删除类属性（当在__delattr__中调用del self.name会引起无限递归）<br>__getattribute__(self, name)：允许你定规则，在任何时候不管一个类属性的值那时候是否可访问。</p>
</blockquote>
<hr>
<h3 id="十一、隐藏在容器背后的魔法"><a href="#十一、隐藏在容器背后的魔法" class="headerlink" title="十一、隐藏在容器背后的魔法"></a>十一、隐藏在容器背后的魔法</h3><blockquote>
<p>__len__(self)：返回容器的长度<br>__getitem__(self, key)：定义当某一个item被访问时的行为，使用self[key]表示法。<br>__setitem__(self, key, value)：定义当某一个item被赋值时候的行为，使用self[key]=value表示法。<br>__delitem__(self, key)：定义当某一个item被删除（例如 del self[key]）时的行为。<br>__iter__(self)：应该给容器返回一个迭代器。迭代器会返回若干内容,大多使用内建函数iter()表示。当一个容器使用形如for x in container:的循环。迭代器本身就是其对象，同时也要定义好一个__iter__方法来返回自身。<br>__reversed__(self)：定义调用内建函数reversed()时的行为。应返回一个反向版本的列表。<br>__contains__(self, item)：__contains__为成员关系，用in和not in测试时定义的行为<br>__concat__(self, other)：定义序列和另外一个序列的连接。</p>
</blockquote>
<hr>
<h3 id="十二、反射"><a href="#十二、反射" class="headerlink" title="十二、反射"></a>十二、反射</h3><blockquote>
<p>__instancecheck__(self, instance)：检查一个实例是否是你定义类中的一个实例(比如，isinstance(instance, class))<br>__subclasscheck__(self, subclass)：检查一个类是否是你定义类的子类比如，issubclass(subclass, class)）</p>
</blockquote>
<hr>
<h3 id="十三、可调用对象"><a href="#十三、可调用对象" class="headerlink" title="十三、可调用对象"></a>十三、可调用对象</h3><blockquote>
<p>__call__(self, [args…])：允许类实例像函数一样被调用。</p>
</blockquote>
<hr>
<h3 id="十四、构建描述符对象"><a href="#十四、构建描述符对象" class="headerlink" title="十四、构建描述符对象"></a>十四、构建描述符对象</h3><p>描述符可以改变其他对象。</p>
<blockquote>
<p>__get__(self, instance, owner)：描述符的值被取回时定义其行为。instance是owner对象的一个实例，owner是所有类。<br>__set__(self, instance, value)：描述符的值被改变时定义其行为。instance是owner对象的一个实例，value是设置的描述符的值<br>__delete__(self, instance)：描述符的值被删除时定义其行为。instance是owner对象的一个实例。</p>
</blockquote>
<hr>
<h3 id="十五、Pickling自定义的对象"><a href="#十五、Pickling自定义的对象" class="headerlink" title="十五、Pickling自定义的对象"></a>十五、Pickling自定义的对象</h3><blockquote>
<p>__getinitargs__(self)：当类unpickled时调用__init__，可以定义__getinitargs__，该方法返回一个元组的参数，然后传递给__init__。（旧式类）<br>__getnewargs__(self)：进行unpickling时将参数传递到__new__。该方法返回一个元组参数，然后能传递给__new__。 （新式类）<br>__getstate__(self)：代替对象的__dict__属性被保存。<br>__setstate__(self, state)：对象unpickled时，如果__setstate__定义对象状态会传递来代替直接用对象的__dict__属性。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;魔法方法即前后各加两个下划线的名字组成的集合所包含的方法。（如果对象实现了魔法方法中的某一个，那么这个方法会在特殊的情况下被调用） &lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;hr&gt;
&lt;h3 id=&quot;一、为确保类是新型的，模块最开始要输入赋值语句-metacla
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>python 模块与包</title>
    <link href="http://yoursite.com/2015/11/30/python%20%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%8C%85/"/>
    <id>http://yoursite.com/2015/11/30/python 模块与包/</id>
    <published>2015-11-29T16:33:53.000Z</published>
    <updated>2016-03-16T07:44:34.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、模块"><a href="#一、模块" class="headerlink" title="一、模块"></a>一、模块</h3><p>模块是一些自我包含并且有组织的代码片段，它可能是一个包含数据成员和方法的类，也可能是一组相关但彼此独立的操作函数。</p>
<hr>
<h3 id="二、模块与文件"><a href="#二、模块与文件" class="headerlink" title="二、模块与文件"></a>二、模块与文件</h3><p>一个文件被看作是一个独立模块，一个模块也可以被看作是一个文件。模块的文件名就是模块名字加扩展名.py,<br>1、模块名称空间：一个名称空间就是一个从名称到对象的关系映射集合。每个模块都定义了它自己的唯一的名称空间，所以在不同模块间不会出现名称交叉。</p>
<hr>
<h3 id="三、名称空间"><a href="#三、名称空间" class="headerlink" title="三、名称空间"></a>三、名称空间</h3><p>名称空间是名称（标识符）到对象的映射。<br>1、在执行期间有两或三个活动的名称空间：局部名称空间（不断变化）、全局名称空间、内建名称空间。解释器首先加载内建名称空间，随后加载执行模块的全局名称空间，它会在模块开始执行后变为活动名称空间，这样就有了两个活动的名称空间。<br>2、名称空间与变量作用域：名称空间是纯粹意义上的名字与对象的映射关系，而作用域指出了用户代码可访问这些名字的物理量。<br>3、名称查找：解释器先从局部名称空间找，再从全局名称空间找，然后从内建名称空间里找。若都失败了，就会返回错误。</p>
<hr>
<h3 id="四、导入模块"><a href="#四、导入模块" class="headerlink" title="四、导入模块"></a>四、导入模块</h3><p>1、import语句：如果在一个模块的顶层导入，其作用域就是全局的，如果在函数中导入，其作用域就是局部的。<br>2、from-import语句：可在模块里导入指定的模块属性，即把指定名称导入到当前作用域。<br>3、多行导入：从一个模块导入许多属性时，import行会越来越长，直至自动换行，且需要一个\。<br>4、from import （as）：使用自己想要的名字来替换模块的原始名称。<br>5、模块导入的特性：（1）导入模块的顶层代码将直接被执行。<br>（2）无论一个模块被导入多少次，它都只被加载一次。（加载第一次导入）<br>（3）用from-import可把名字导入当前名称空间，所以不需要使用属性/句点属性标知来访问模块的标识符。<br>（4）只从模块导入名字会使那些名字成为局部名称空间的一部分，这可能导致覆盖一个已经存在的具有相同名字的对象。且改变这些变量只影响它局部拷贝而非导入模块的原始名称空间。<br>（5）从ZIP归档文件导入模块。</p>
<hr>
<h3 id="五、模块内建函数"><a href="#五、模块内建函数" class="headerlink" title="五、模块内建函数"></a>五、模块内建函数</h3><p>1、import ()：模块导入。<br>2、globals()、locals() ：包含当前全局符号表的名字的字典/包含局部符号表的名字的字典<br>3、reload()：重新导入一个已经导入的模块，其参数必须是模块自身而不是包含模块名的字符串</p>
<hr>
<h3 id="六、包"><a href="#六、包" class="headerlink" title="六、包"></a>六、包</h3><p>包是一个有层次的文件目录结构，它定义了一个由模块和子包组成的python应用程序执行环境。包也使用句点属性标知来访问它们的函数。<br>1、绝对导入：导入子包会导致与真正的标准库模块（事实上是它们的名字）发生冲突，会把名字相同的标准库模块隐藏掉。这些名字必须通过Python路径来访问。<br>2、相对导入：只用于from-import语句，明确在子包中某个模块的位置。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、模块&quot;&gt;&lt;a href=&quot;#一、模块&quot; class=&quot;headerlink&quot; title=&quot;一、模块&quot;&gt;&lt;/a&gt;一、模块&lt;/h3&gt;&lt;p&gt;模块是一些自我包含并且有组织的代码片段，它可能是一个包含数据成员和方法的类，也可能是一组相关但彼此独立的操作函数。&lt;/p&gt;

    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>理解 python 面向对象</title>
    <link href="http://yoursite.com/2015/11/13/python%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2015/11/13/python 面向对象总结/</id>
    <published>2015-11-13T14:35:12.000Z</published>
    <updated>2016-04-20T14:04:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="对象"><a href="#对象" class="headerlink" title="对象:"></a>对象:</h2><p><strong>对象是要研究的任何事物,它不仅能表示具体的事物，还能表示抽象的东西。类是在对象之上的抽象，对象则是类的具体化，是类的实例。</strong><br>1.一个对象用数据值来描述它的状态。<br>2.用于改变对象的状态，对象及其操作就是对象的行为。</p>
<hr>
<h2 id="类："><a href="#类：" class="headerlink" title="类："></a>类：</h2><blockquote>
<p>类可以对具有相同数据和方法的对象（即属性相近的对象）描述或定义。类是现实世界的抽象的实体以编程形式出现，实例是这些对象的具体化。</p>
</blockquote>
<p>类，实际上也是一种数据结构，像元组，列表那些。当我们定义了一个类，实际上相当于<strong>自己创建一个数据类型</strong>。而元组、列表等，这些数据类型其实相当于python内建的数据类型。</p>
<p>就像函数那样，python也有许多内建函数，但往往我们还要自己定义函数。</p>
<p>所以这就是面向对象编程和函数编程。面向对象编程就是新建一些封装了行为的对象（类型），函数编程就是新定义一些封装了对象（类型）的行为。</p>
<p>1.定义类：</p>
<pre><code>class ClassName(bases):           #类定义也和函数定义类似
    &apos;class documentation string&apos;
    class_suite  #类体。包含所有声明语句、类成员定义、数据属性、和函数。
</code></pre><p>当一个类定义完之后，就产生了一个类对象。而实例化是产生出一个类对象的实例，称作实例对象。</p>
<p><strong>注意：</strong></p>
<ul>
<li>基类就是一个或多个用于继承的父类的集合。</li>
<li>类通常在一个模块的顶层进行定义。想想，如果它相当于元组、列表这些数据类型，那肯定要早早定义才能像‘内建数据类型’（元组等）那样正常使用。</li>
<li>声明和定义的区别：看上面那串伪代码，含class关键字的头行和第二行类文档字符串就是声明，类体就是定义。</li>
</ul>
<p>2.类定义完成后可通过类对象来访问类的属性和方法。实例化后，可以通过实例对象来访问属性和方法，栗子：</p>
<pre><code>class bird:
    name = &apos;Jack&apos;
    age = 18
b = bird()
print b.name,b.age`
</code></pre><p>这里定义了一个鸟类。有姓名、年龄属性。<br>b=bird()实例化了一个对象b，然后就可通过b来读取属性。(这里的name和age是公有的，可在类外通过对象名直接访问，如果想定义成私有的，需在前面加2个下划线。)</p>
<p>为了更好地理解实例化，举一个列表的栗子：（上面说过类和它们一样是一种数据类型）</p>
<pre><code>a = []
</code></pre><p>这里大概谁都能看得懂发生了什么，就是创建了一个列表‘a’，也就相当于:</p>
<pre><code>a = list()
</code></pre><p>这样看起来就和类的实例化很像了吧，所以实例化其实也就是这么个意思。其实只要把类想象成像列表那样的‘内建数据类型’，一切关于类的东西就很好理解了。</p>
<p>所以才说：</p>
<blockquote>
<p>在python中，一切皆对象。</p>
</blockquote>
<p>类是对象，列表、元组等也是对象。类定义完后产生了一个类对象，于是你也可以把元组看成‘元组对象’，把列表看成‘列表对象’。</p>
<p>2.类属性</p>
<blockquote>
<p>属性就是属于另一个对象的数据或者函数元素，可以通过句点属性标识法来访问。</p>
</blockquote>
<p>类属性仅仅与其被定义的类相绑定，类属性分为数据属性和函数属性（方法）。</p>
<ul>
<li>数据属性</li>
</ul>
<p><strong>数据属性就是所定义的类的变量。</strong>它们像其他变量一样在类创建后被使用，它们可以由类中的方法更新，也可以在主程序的其他地方更新。</p>
<p>这种变量也叫静态变量，或者是静态数据，它们与它们所属的类对象绑定，不依赖与任何类实例。</p>
<pre><code>&gt;&gt;&gt; class C(object):
...    foo = 100
&gt;&gt;&gt; print C.foo
100
&gt;&gt;&gt; C.foo = C.foo + 1
&gt;&gt;&gt; print C.foo
101
</code></pre><ul>
<li>函数属性</li>
</ul>
<p>在类中也可以定义函数，这些函数就是方法。不难理解，像列表那些类型也有许多方法，那么这个自己创建的类型自然也能自己定义方法。</p>
<p>方法是作为类定义的一部分，在类中定义的函数，这使得方法也成为类的属性。即这些方法也仅能应用于所属的类型的对象的实例上。</p>
<p>方法通过句点属性标识法与它的实例绑定。注意：它是一个方法，属于一个类，而不是全局空间中的名字。</p>
<pre><code>&gt;&gt;&gt; class MyClass(object):
        def myNoActionMethod(self):
            pass

&gt;&gt;&gt; mc = Myclass()
&gt;&gt;&gt; mc.myNoActionMethod()    
</code></pre><p>注意：</p>
<ul>
<li>没有实例，方法是不能被调用的。方法必须绑定（到一个实例）才能直接被调用。即上面的栗子不能通过Myclass.myNoActionMethod()调用，这也不难理解，就像你不会list.append()来调用append()方法，而是会先创建一个列表实例。</li>
<li>方法的第一个参数必须是self，无论是否用到。</li>
<li><p>方法是与类对象或实例对象进行绑定了的，而函数没有与对象绑定。</p>
</li>
<li><p>类的内置方法:</p>
</li>
</ul>
<blockquote>
<p>__init__ :构造方法（ 初始化对象）<br>__del__:析构方法（释放对象）<br>__new__:生成实例<br>__getattr__: 获取属性的值<br>__setattr__:设置属性的值<br>__delattr__:删除name属性<br>__getitem__: 获取序列的索引对应的值<br>__cmp__:比较两个对象<br>__call__:把实例对象作为函数调用     等等等等….</p>
</blockquote>
<p>3.特殊的类属性</p>
<blockquote>
<p>C.__name__: 类C的名字（字符串形式）<br>C.<em>\</em>\doc__:类C的文档字符串<br>C.<em>\</em>\bases__:类C的所有父类构成的元组<br>C.<em>\</em>\dict__:类C的属性<br>C.<em>\</em>\module__:类C定义所在的模块<br>C.<em>\</em>\class__:实例C对应的类（仅新式类中）</p>
</blockquote>
<p>4.实例/实例属性(待加)</p>
<ul>
<li>类属性和实例属性:(待加)</li>
</ul>
<p>类属性是类对象所拥有的，被所有类对象的实例对象所共有,另外可通过类对象和实例对象访问。在类外修改类属性，须通过类对象去引用后再修改。如通过实例对象去引用，会产生一个同名的实例属性，修改的是实例属性非类属性。如果通过实例对象去引用该名称的属性，实例属性会强制屏蔽类属性（即引用的是实例属性)。</p>
<hr>
<h3 id="继承：-待改"><a href="#继承：-待改" class="headerlink" title="继承：(待改)"></a>继承：(待改)</h3><p>类别本身还可以进一步细分成子类，子类通过继承享有了父类的所有属性（数据属性和方法）。通过继承，减少了程序中的重复信息和重复语句。另外，子类也可以覆盖父类同名的变量和方法。<br>1.子类继承父类所有的公有属性和方法，可在子类中通过父类名来调用，而对于私有的属性和方法，子类不进行继承，因此在子类中无法通过父类名来访问。<br>2.继承的特点：<br>（1）如果父类和子类都重新定义了构造方法__init__，在进行子类实例化的时候，子类的构造方法不会自动调用父类的构造方法，必须在子类中显示调用。<br>（2）在调用基类的方法时，需要加上基类的类名前缀（以 父类名.方法 这种方式调用），且需要带上self参数变量。而在类中调用普通函数时并不需要带上self参数<br>（3）Python总是首先查找对应类型的方法，如果它不能在派生类中找到对应的方法，它才开始到基类中逐个查找。（先在本类中查找调用的方法，找不到才去基类中找）。<br>3.在传统类中，如果子类和父类中同名的方法或者属性，在查找的时候基本遵循自左到右，深度优先的原则。新式类中，则采用“广度优先”的方式去查找属性。<br>4.在类层次中，子类继承了多个父类的数据结构和方法，那么它就被称作”多重继承”（如果有多个父类，多个父类名之间用逗号隔开）。<br>5.关于继承的构造函数：<br>（1）若子类没有定义自己的构造函数，父类的构造函数会被默认调用，但是此时如果要实例化子类的对象，则只能传入父类的构造函数对应的参数。<br>（2）若子类定义了自己的构造函数，而没有显示调用父类的构造函数，则父类的属性不会被初始化。<br>（3）若子类定义了自己的构造函数，显示调用父类，子类和父类的属性都会被初始化。</p>
<hr>
<h3 id="多态：-待改"><a href="#多态：-待改" class="headerlink" title="多态：(待改)"></a>多态：(待改)</h3><p>不同的对象，收到同一消息可以产生不同的结果，每个对象以适合自身的方式去响应共同的消息。允许将父对象设置成为和它的子对象相等，使得能够利用同一类(基类)类型的指针来引用不同类的对象,以及根据所引用对象的不同,以不同的方式执行相同的操作并获得不同的结果.</p>
<hr>
<h3 id="封装：-信息隐藏-待改"><a href="#封装：-信息隐藏-待改" class="headerlink" title="封装：(信息隐藏) (待改)"></a>封装：(信息隐藏) (待改)</h3><p>把类的属性和方法封装在类中，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。就是只提供调用接口，但是不公布实现细节。</p>
<hr>
<h3 id="新式类和经典类：待改"><a href="#新式类和经典类：待改" class="headerlink" title="新式类和经典类：待改)"></a>新式类和经典类：待改)</h3><p>1.新型类默认的元类为type，经典类默认类型为types.ClassType<br>2.新型类是在Python2.2中引入的，所有的新式类必须继承至少一个父类，如果类没有继承任何其他父类，则object将作为默认的父类。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;对象&quot;&gt;&lt;a href=&quot;#对象&quot; class=&quot;headerlink&quot; title=&quot;对象:&quot;&gt;&lt;/a&gt;对象:&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;对象是要研究的任何事物,它不仅能表示具体的事物，还能表示抽象的东西。类是在对象之上的抽象，对象则是类的具体化，是类的实例
    
    </summary>
    
    
  </entry>
  
</feed>
